@echo off
echo ===================================
echo Discord Bot å•Ÿå‹•è…³æœ¬ (æœ€æ–°ç‰ˆæœ¬)
echo ===================================
echo.
echo æ­¤è…³æœ¬å°‡å•Ÿå‹• Discord æ©Ÿå™¨äºº
echo åŠŸèƒ½: æ”¯æŒ2025å¹´åœ°éœ‡è³‡æ–™æ–°æ ¼å¼åŠå…¶ä»–å„ªåŒ–
echo.
echo æŒ‰ä»»æ„éµé–‹å§‹å•Ÿå‹•æ©Ÿå™¨äºº...
pause > nul

echo.
echo æª¢æŸ¥ Python æ˜¯å¦å·²å®‰è£...
python --version > nul 2>&1
if %errorlevel% neq 0 (
    echo [éŒ¯èª¤] æ‰¾ä¸åˆ° Pythonã€‚è«‹ç¢ºèª Python å·²å®‰è£ä¸”æ·»åŠ åˆ°ç³»çµ±è·¯å¾‘ä¸­ã€‚
    goto :error
)

echo [æˆåŠŸ] Python å·²å®‰è£

echo æª¢æŸ¥æ˜¯å¦å­˜åœ¨å¿…è¦çš„æª”æ¡ˆ...
if not exist "bot.py" (
    echo [éŒ¯èª¤] æ‰¾ä¸åˆ° bot.py æª”æ¡ˆã€‚è«‹ç¢ºèªæ‚¨åœ¨æ­£ç¢ºçš„ç›®éŒ„ä¸­åŸ·è¡Œæ­¤è…³æœ¬ã€‚
    goto :error
)

if not exist "cogs\info_commands_fixed_v4.py" (
    echo [éŒ¯èª¤] æ‰¾ä¸åˆ° cogs\info_commands_fixed_v4.py æª”æ¡ˆã€‚
    goto :error
)

echo [æˆåŠŸ] æ‰¾åˆ°æ‰€æœ‰å¿…è¦æª”æ¡ˆ

echo æª¢æŸ¥æ˜¯å¦å·²å®‰è£å¿…è¦çš„å¥—ä»¶...
python -c "import discord, asyncio, aiohttp, google.generativeai, dotenv" > nul 2>&1
if %errorlevel% neq 0 (
    echo [è­¦å‘Š] å¯èƒ½ç¼ºå°‘ä¸€äº›å¿…è¦çš„å¥—ä»¶ã€‚å˜—è©¦å®‰è£...
    echo å®‰è£å¿…è¦çš„å¥—ä»¶...
    pip install -r requirements.txt
    if %errorlevel% neq 0 (
        echo [éŒ¯èª¤] å®‰è£å¥—ä»¶æ™‚ç™¼ç”ŸéŒ¯èª¤ã€‚
        goto :error
    )
)

echo [æˆåŠŸ] æ‰€æœ‰å¿…è¦å¥—ä»¶å·²å®‰è£

echo æ­£åœ¨è¨­ç½®ç¶²è·¯ç’°å¢ƒ...
set PYTHONHTTPSVERIFY=0
set AIOHTTP_NO_EXTENSIONS=1
set SSL_CERT_FILE=
set REQUESTS_CA_BUNDLE=
set CURL_CA_BUNDLE=

echo.
echo æ­£åœ¨å•Ÿå‹• Discord æ©Ÿå™¨äºº...
echo è«‹ç­‰å¾…ç´„ 1-2 åˆ†é˜ï¼Œè®“æ–œç·šæŒ‡ä»¤å®ŒæˆåŒæ­¥...
echo.
echo å•Ÿå‹•æ—¥èªŒ:
echo ------------------------------

python -X dev bot.py
if errorlevel 1 (    echo éŒ¯èª¤ï¼šæ©Ÿå™¨äººå•Ÿå‹•å¤±æ•—
    goto :error
)

:error
echo.
echo [éŒ¯èª¤] å•Ÿå‹•æ©Ÿå™¨äººæ™‚ç™¼ç”ŸéŒ¯èª¤ã€‚
echo è«‹æª¢æŸ¥ä¸Šæ–¹çš„éŒ¯èª¤è¨Šæ¯ï¼Œæˆ–æŸ¥çœ‹ bot.log æª”æ¡ˆä»¥ç²å–æ›´è©³ç´°çš„éŒ¯èª¤è³‡è¨Šã€‚
pause
exit /b 1

:end
echo.
echo æ©Ÿå™¨äººå·²åœæ­¢é‹è¡Œã€‚
pause
exit /b 0
class WeatherSelectView(View):
    def __init__(self, cog):
        super().__init__(timeout=120)  # è¨­å®šé¸å–®è¶…æ™‚æ™‚é–“ç‚º120ç§’
        self.cog = cog
        self.add_item(self.create_select_menu())
echo.
    def create_select_menu(self):
        select = Select(            placeholder="è«‹é¸æ“‡ç¸£å¸‚...",            min_values=1,            max_values=1        )                # ä¾ç…§å€åŸŸåˆ†çµ„æ·»åŠ é¸é …        for region, cities in TW_REGIONS.items():            for city in cities:                select.add_option(                    label=city,                    value=city,                    description=f"{region}åœ°å€",                    emoji="ğŸŒ†" if city.endswith("å¸‚") else "ğŸï¸"                )                select.callback = self.select_callback        return select    async def select_callback(self, interaction: discord.Interaction):        """è™•ç†ç¸£å¸‚é¸æ“‡å¾Œçš„å›èª¿å‡½æ•¸"""        selected_city = interaction.data["values"][0]                try:            await interaction.response.defer(ephemeral=False, thinking=True)                        # ç²å–å¤©æ°£è³‡æ–™            try:                async with asyncio.timeout(5):  # è¨­å®š5ç§’è¶…æ™‚                    data = await self.cog.fetch_weather_data()            except asyncio.TimeoutError:                # å¦‚æœè¶…æ™‚ï¼Œæª¢æŸ¥å¿«å–                data = self.cog.weather_cache                                if not data:                    await interaction.followup.send(                        embed=discord.Embed(                            title="âš ï¸ è™•ç†è¶…æ™‚",                            description="ç²å–å¤©æ°£è³‡æ–™æ™‚ç™¼ç”Ÿå»¶é²ï¼Œè«‹ç¨å¾Œå†è©¦",                            color=discord.Color.orange()                        )                    )                    return                        if not data:                await interaction.followup.send(                    embed=discord.Embed(                        title="âŒ éŒ¯èª¤",                        description="ç„¡æ³•ç²å–å¤©æ°£è³‡æ–™ï¼Œè«‹ç¨å¾Œå†è©¦",                        color=discord.Color.red()                    )                )                return                        # æ ¼å¼åŒ–ä¸¦ç™¼é€å¤©æ°£è³‡æ–™            embed = self.cog.format_weather_data(data, selected_city)            await interaction.followup.send(embed=embed)            logger.info(f"ç”¨æˆ¶ {interaction.user} æŸ¥è©¢äº† {selected_city} çš„å¤©æ°£é å ±")                    except Exception as e:            logger.error(f"è™•ç†å¤©æ°£æŸ¥è©¢é¸æ“‡æ™‚ç™¼ç”ŸéŒ¯èª¤: {str(e)}")            await interaction.followup.send(                embed=discord.Embed(                    title="âŒ éŒ¯èª¤",                    description="è™•ç†é¸æ“‡æ™‚ç™¼ç”ŸéŒ¯èª¤ï¼Œè«‹ç¨å¾Œå†è©¦",                    color=discord.Color.red()                )            )                async def on_timeout(self):        """è™•ç†é¸å–®é€¾æ™‚"""        # é¸å–®é€¾æ™‚æ™‚ï¼Œç¦ç”¨æ‰€æœ‰é¸é …        for item in self.children:            item.disabled = Trueclass ReservoirSelectView(View):    def __init__(self, cog):        super().__init__(timeout=120)  # è¨­å®šé¸å–®è¶…æ™‚æ™‚é–“ç‚º120ç§’        self.cog = cog        self.add_item(self.create_select_menu())    def create_select_menu(self):        """å‰µå»ºæ°´åº«é¸æ“‡é¸å–®"""        select = Select(            placeholder="é¸æ“‡è¦æŸ¥è©¢çš„æ°´åº«",            min_values=1,            max_values=1        )        reservoirs_by_region = {            "åŒ—éƒ¨": ["çŸ³é–€æ°´åº«", "å¯¶å±±ç¬¬äºŒæ°´åº«", "æ°¸å’Œå±±æ°´åº«", "å¯¶å±±æ°´åº«", "å¾·åŸºæ°´åº«"],            "ä¸­éƒ¨": ["é¯‰é­šæ½­æ°´åº«", "å¾·åŸºæ°´åº«", "éœ§ç¤¾æ°´åº«", "æ—¥æœˆæ½­æ°´åº«", "ä»ç¾©æ½­æ°´åº«"],            "å—éƒ¨": ["æ›¾æ–‡æ°´åº«", "çƒå±±é ­æ°´åº«", "å—åŒ–æ°´åº«", "é˜¿å…¬åº—æ°´åº«", "ç‰¡ä¸¹æ°´åº«"]        }                try:            # è¨ˆç®—ç¸½é¸é …æ•¸é‡ï¼Œç¢ºä¿ä¸è¶…é25å€‹            total_options = sum(len(reservoirs) for reservoirs in reservoirs_by_region.values())            logger.info(f"æ°´åº«é¸å–®é¸é …æ•¸é‡: {total_options}")                        if total_options > 25:                logger.warning("æ°´åº«é¸é …è¶…é25å€‹ï¼Œå°‡é€²è¡Œè£å‰ª")                            # æ·»åŠ æ°´åº«é¸é …            option_count = 0            for region, reservoirs in reservoirs_by_region.items():                for reservoir in reservoirs:                    if option_count < 25:  # ç¢ºä¿ä¸è¶…é25å€‹é¸é …                        select.add_option(                            label=reservoir,                            value=reservoir,                            description=f"{region}åœ°å€",                            emoji="ğŸ’§"                        )                        option_count += 1                    else:                        logger.warning(f"å·²é”é¸é …ä¸Šé™ï¼Œç•¥éæ°´åº«: {reservoir}")        except Exception as e:            logger.error(f"å»ºç«‹æ°´åº«é¸å–®æ™‚ç™¼ç”ŸéŒ¯èª¤: {str(e)}")            # ç™¼ç”ŸéŒ¯èª¤æ™‚æ·»åŠ ä¸€å€‹é è¨­é¸é …            select.add_option(                label="éŒ¯èª¤",                value="error",                description="ç„¡æ³•è¼‰å…¥æ°´åº«é¸é …",                emoji="âš ï¸"            )                select.callback = self.select_callback        return select    async def select_callback(self, interaction: discord.Interaction):        """è™•ç†æ°´åº«é¸æ“‡å¾Œçš„å›èª¿å‡½æ•¸"""        selected_reservoir = interaction.data["values"][0]                try:            await interaction.response.defer(ephemeral=False, thinking=True)                        # ç²å–æ°´åº«è³‡æ–™            try:                async with asyncio.timeout(5):  # è¨­å®š5ç§’è¶…æ™‚                    data = await self.cog.fetch_reservoir_data()            except asyncio.TimeoutError:                # å¦‚æœè¶…æ™‚ï¼Œæª¢æŸ¥å¿«å–                data = self.cog.reservoir_cache                                if not data:                    await interaction.followup.send(                        embed=discord.Embed(                            title="âš ï¸ è™•ç†è¶…æ™‚",                            description="ç²å–æ°´åº«è³‡æ–™æ™‚ç™¼ç”Ÿå»¶é²ï¼Œè«‹ç¨å¾Œå†è©¦",                            color=discord.Color.orange()                        )                    )                    return                        if not data:                await interaction.followup.send(                    embed=discord.Embed(                        title="âŒ éŒ¯èª¤",                        description="ç„¡æ³•ç²å–æ°´åº«è³‡æ–™ï¼Œè«‹ç¨å¾Œå†è©¦",                        color=discord.Color.red()                    )                )                return                        # æ ¼å¼åŒ–ä¸¦ç™¼é€æ°´åº«è³‡æ–™            embed = self.cog.format_reservoir_data(data, selected_reservoir)            await interaction.followup.send(embed=embed)            logger.info(f"ç”¨æˆ¶ {interaction.user} æŸ¥è©¢äº† {selected_reservoir} çš„æ°´åº«æƒ…æ³")                    except Exception as e:            logger.error(f"è™•ç†æ°´åº«æŸ¥è©¢é¸æ“‡æ™‚ç™¼ç”ŸéŒ¯èª¤: {str(e)}")            await interaction.followup.send(                embed=discord.Embed(                    title="âŒ éŒ¯èª¤",                    description="è™•ç†é¸æ“‡æ™‚ç™¼ç”ŸéŒ¯èª¤ï¼Œè«‹ç¨å¾Œå†è©¦",                    color=discord.Color.red()                )            )                async def on_timeout(self):        """è™•ç†é¸å–®é€¾æ™‚"""        # é¸å–®é€¾æ™‚æ™‚ï¼Œç¦ç”¨æ‰€æœ‰é¸é …        for item in self.children:            item.disabled = Trueclass WaterInfoSelectView(View):    def __init__(self, cog):        super().__init__(timeout=120)  # è¨­å®šé¸å–®è¶…æ™‚æ™‚é–“ç‚º120ç§’        self.cog = cog        self.add_item(self.create_select_menu())    def create_select_menu(self):        """å‰µå»ºæ°´åº«é¸æ“‡é¸å–®"""        select = Select(            placeholder="é¸æ“‡è¦æŸ¥è©¢çš„æ°´åº«",            min_values=1,            max_values=1        )        reservoirs_by_region = {            "åŒ—éƒ¨": ["çŸ³é–€æ°´åº«", "å¯¶å±±ç¬¬äºŒæ°´åº«", "æ°¸å’Œå±±æ°´åº«", "å¯¶å±±æ°´åº«", "å¾·åŸºæ°´åº«"],            "ä¸­éƒ¨": ["é¯‰é­šæ½­æ°´åº«", "å¾·åŸºæ°´åº«", "éœ§ç¤¾æ°´åº«", "æ—¥æœˆæ½­æ°´åº«", "ä»ç¾©æ½­æ°´åº«"],            "å—éƒ¨": ["æ›¾æ–‡æ°´åº«", "çƒå±±é ­æ°´åº«", "å—åŒ–æ°´åº«", "é˜¿å…¬åº—æ°´åº«", "ç‰¡ä¸¹æ°´åº«"]        }                try:            # è¨ˆç®—ç¸½é¸é …æ•¸é‡ï¼Œç¢ºä¿ä¸è¶…é25å€‹            total_options = sum(len(reservoirs) for reservoirs in reservoirs_by_region.values())            logger.info(f"æ°´åº«é¸å–®é¸é …æ•¸é‡: {total_options}")                        if total_options > 25:                logger.warning("æ°´åº«é¸é …è¶…é25å€‹ï¼Œå°‡é€²è¡Œè£å‰ª")                            # æ·»åŠ æ°´åº«é¸é …            option_count = 0            for region, reservoirs in reservoirs_by_region.items():                for reservoir in reservoirs:                    if option_count < 25:  # ç¢ºä¿ä¸è¶…é25å€‹é¸é …                        select.add_option(                            label=reservoir,                            value=reservoir,                            description=f"{region}åœ°å€",                            emoji="ğŸ’§"                        )                        option_count += 1                    else:                        logger.warning(f"å·²é”é¸é …ä¸Šé™ï¼Œç•¥éæ°´åº«: {reservoir}")        except Exception as e:            logger.error(f"å»ºç«‹æ°´åº«é¸å–®æ™‚ç™¼ç”ŸéŒ¯èª¤: {str(e)}")            # ç™¼ç”ŸéŒ¯èª¤æ™‚æ·»åŠ ä¸€å€‹é è¨­é¸é …            select.add_option(                label="éŒ¯èª¤",                value="error",                description="ç„¡æ³•è¼‰å…¥æ°´åº«é¸é …",                emoji="âš ï¸"            )                select.callback = self.select_callback        return select    async def select_callback(self, interaction: discord.Interaction):        """è™•ç†æ°´åº«é¸æ“‡å¾Œçš„å›èª¿å‡½æ•¸"""        selected_reservoir = interaction.data["values"][0]                try:            await interaction.response.defer(ephemeral=False, thinking=True)                        # ç²å–æ°´åº«è³‡æ–™            try:                async with asyncio.timeout(5):  # è¨­å®š5ç§’è¶…æ™‚                    data = await self.cog.fetch_water_info_data()            except asyncio.TimeoutError:                # å¦‚æœè¶…æ™‚ï¼Œæª¢æŸ¥å¿«å–                data = self.cog.water_info_cache                                if not data:                    await interaction.followup.send(                        embed=discord.Embed(                            title="âš ï¸ è™•ç†è¶…æ™‚",                            description="ç²å–æ°´æƒ…è³‡æ–™æ™‚ç™¼ç”Ÿå»¶é²ï¼Œè«‹ç¨å¾Œå†è©¦",                            color=discord.Color.orange()                        )                    )                    return                        if not data:                await interaction.followup.send(                    embed=discord.Embed(                        title="âŒ éŒ¯èª¤",                        description="ç„¡æ³•ç²å–æ°´æƒ…è³‡æ–™ï¼Œè«‹ç¨å¾Œå†è©¦",                        color=discord.Color.red()                    )                )                return                        # æ ¼å¼åŒ–ä¸¦ç™¼é€æ°´åº«è³‡æ–™            embed = self.cog.format_water_info_data(data, selected_reservoir)            await interaction.followup.send(embed=embed)            logger.info(f"ç”¨æˆ¶ {interaction.user} æŸ¥è©¢äº† {selected_reservoir} çš„æ°´æƒ…")                    except Exception as e:            logger.error(f"è™•ç†æ°´æƒ…æŸ¥è©¢é¸æ“‡æ™‚ç™¼ç”ŸéŒ¯èª¤: {str(e)}")            await interaction.followup.send(                embed=discord.Embed(                    title="âŒ éŒ¯èª¤",                    description="è™•ç†é¸æ“‡æ™‚ç™¼ç”ŸéŒ¯èª¤ï¼Œè«‹ç¨å¾Œå†è©¦",                    color=discord.Color.red()                )            )                async def on_timeout(self):        """è™•ç†é¸å–®é€¾æ™‚"""        # é¸å–®é€¾æ™‚æ™‚ï¼Œç¦ç”¨æ‰€æœ‰é¸é …        for item in self.children:            item.disabled = Trueclass TownWeatherSelectView(View):    def __init__(self, cog):        super().__init__(timeout=120)  # è¨­å®šé¸å–®è¶…æ™‚æ™‚é–“ç‚º120ç§’        self.cog = cog        self.add_item(self.create_select_menu())    def create_select_menu(self):        select = Select(            placeholder="è«‹é¸æ“‡é„‰é®...",            min_values=1,            max_values=1        )                # å°åŒ—å¸‚é„‰é®åˆ—è¡¨        taipei_towns = [            "æ¾å±±å€", "ä¿¡ç¾©å€", "å¤§å®‰å€", "ä¸­å±±å€", "ä¸­æ­£å€", "å¤§åŒå€",            "è¬è¯å€", "æ–‡å±±å€", "å—æ¸¯å€", "å…§æ¹–å€", "å£«æ—å€", "åŒ—æŠ•å€"        ]                # æ–°åŒ—å¸‚é„‰é®åˆ—è¡¨ï¼ˆéƒ¨åˆ†ï¼‰        new_taipei_towns = [            "æ¿æ©‹å€", "ä¸‰é‡å€", "ä¸­å’Œå€", "æ°¸å’Œå€", "æ–°èŠå€", "æ–°åº—å€",            "æ¨¹æ—å€", "é¶¯æ­Œå€", "ä¸‰å³½å€", "æ·¡æ°´å€", "æ±æ­¢å€", "ç‘èŠ³å€"        ]                # ä¾ç…§å€åŸŸåˆ†çµ„æ·»åŠ é¸é …        for town in taipei_towns:            select.add_option(                label=town,                value=town,                description="å°åŒ—å¸‚",                emoji="ğŸ™ï¸"            )                for town in new_taipei_towns:            select.add_option(                label=town,                value=town,                description="æ–°åŒ—å¸‚",                emoji="ğŸŒ†"            )                select.callback = self.select_callback        return select    async def select_callback(self, interaction: discord.Interaction):        """è™•ç†é„‰é®é¸æ“‡å¾Œçš„å›èª¿å‡½æ•¸"""        selected_town = interaction.data["values"][0]                try:            await interaction.response.defer(ephemeral=False, thinking=True)                        # ç²å–å¤©æ°£è³‡æ–™            try:                async with asyncio.timeout(5):  # è¨­å®š5ç§’è¶…æ™‚                    data = await self.cog.fetch_town_weather_data()            except asyncio.TimeoutError:                # å¦‚æœè¶…æ™‚ï¼Œæª¢æŸ¥å¿«å–                data = self.cog.town_weather_cache                                if not data:                    await interaction.followup.send(                        embed=discord.Embed(                            title="âš ï¸ è™•ç†è¶…æ™‚",                            description="ç²å–å¤©æ°£è³‡æ–™æ™‚ç™¼ç”Ÿå»¶é²ï¼Œè«‹ç¨å¾Œå†è©¦",                            color=discord.Color.orange()                        )                    )                    return                        if not data:                await interaction.followup.send(                    embed=discord.Embed(                        title="âŒ éŒ¯èª¤",                        description="ç„¡æ³•ç²å–å¤©æ°£è³‡æ–™ï¼Œè«‹ç¨å¾Œå†è©¦",                        color=discord.Color.red()                    )                )                return                        # æ ¼å¼åŒ–ä¸¦ç™¼é€å¤©æ°£è³‡æ–™            embed = self.cog.format_town_weather_data(data, selected_town)            await interaction.followup.send(embed=embed)            logger.info(f"ç”¨æˆ¶ {interaction.user} æŸ¥è©¢äº† {selected_town} çš„å¤©æ°£é å ±")                    except Exception as e:            logger.error(f"è™•ç†å¤©æ°£æŸ¥è©¢é¸æ“‡æ™‚ç™¼ç”ŸéŒ¯èª¤: {str(e)}")            await interaction.followup.send(                embed=discord.Embed(                    title="âŒ éŒ¯èª¤",                    description="è™•ç†é¸æ“‡æ™‚ç™¼ç”ŸéŒ¯èª¤ï¼Œè«‹ç¨å¾Œå†è©¦",                    color=discord.Color.red()                )            )                async def on_timeout(self):        """è™•ç†é¸å–®é€¾æ™‚"""        # é¸å–®é€¾æ™‚æ™‚ï¼Œç¦ç”¨æ‰€æœ‰é¸é …        for item in self.children:            item.disabled = True# æ–°å¢æ°´åº«æ°´æƒ…è³‡æ–™åˆ†é å™¨é¡åˆ¥class WaterInfoPaginator(discord.ui.View):    """ç”¨æ–¼åˆ†é é¡¯ç¤ºæ‰€æœ‰æ°´åº«æ°´æƒ…è³‡æ–™çš„åˆ†é å™¨"""        def __init__(self, embeds: list, timeout: int = 180):        super().__init__(timeout=timeout)        self.embeds = embeds        self.current_page = 0        self.total_pages = len(embeds)                # æ›´æ–°æŒ‰éˆ•ç‹€æ…‹        self._update_buttons()        def _update_buttons(self):        """æ›´æ–°æŒ‰éˆ•ç‹€æ…‹"""        # ç¬¬ä¸€é æ™‚ï¼Œç¦ç”¨ä¸Šä¸€é å’Œç¬¬ä¸€é æŒ‰éˆ•        self.first_page.disabled = (self.current_page == 0)        self.prev_page.disabled = (self.current_page == 0)                # æœ€å¾Œä¸€é æ™‚ï¼Œç¦ç”¨ä¸‹ä¸€é å’Œæœ€å¾Œä¸€é æŒ‰éˆ•        self.next_page.disabled = (self.current_page == self.total_pages - 1)        self.last_page.disabled = (self.current_page == self.total_pages - 1)        async def update_message(self, interaction: discord.Interaction):        """æ›´æ–°è¨Šæ¯ä»¥é¡¯ç¤ºç•¶å‰é é¢"""        embed = self.embeds[self.current_page]        # æ·»åŠ é ç¢¼è³‡è¨Šåˆ°åµŒå…¥è¨Šæ¯        embed.set_footer(text=f"ç¬¬ {self.current_page + 1}/{self.total_pages} é  | è³‡æ–™ä¾†æº: ç¶“æ¿Ÿéƒ¨æ°´åˆ©ç½²")        self._update_buttons()        await interaction.response.edit_message(embed=embed, view=self)        @discord.ui.button(label="é¦–é ", style=discord.ButtonStyle.gray, emoji="â®ï¸")    async def first_page(self, interaction: discord.Interaction, button: discord.ui.Button):        """è·³è½‰åˆ°ç¬¬ä¸€é """        self.current_page = 0        await self.update_message(interaction)        @discord.ui.button(label="ä¸Šä¸€é ", style=discord.ButtonStyle.blurple, emoji="â—€ï¸")    async def prev_page(self, interaction: discord.Interaction, button: discord.ui.Button):        """é¡¯ç¤ºä¸Šä¸€é """        self.current_page -= 1        if self.current_page < 0:            self.current_page = 0        await self.update_message(interaction)        @discord.ui.button(label="ä¸‹ä¸€é ", style=discord.ButtonStyle.blurple, emoji="â–¶ï¸")    async def next_page(self, interaction: discord.Interaction, button: discord.ui.Button):        """é¡¯ç¤ºä¸‹ä¸€é """        self.current_page += 1        if self.current_page >= self.total_pages:            self.current_page = self.total_pages - 1        await self.update_message(interaction)        @discord.ui.button(label="å°¾é ", style=discord.ButtonStyle.gray, emoji="â­ï¸")    async def last_page(self, interaction: discord.Interaction, button: discord.ui.Button):        """è·³è½‰åˆ°æœ€å¾Œä¸€é """        self.current_page = self.total_pages - 1        await self.update_message(interaction)        async def on_timeout(self):        """è™•ç†åˆ†é å™¨é€¾æ™‚"""        # åˆ†é å™¨é€¾æ™‚æ™‚ï¼Œç¦ç”¨æ‰€æœ‰æŒ‰éˆ•        for item in self.children:            item.disabled = Trueclass InfoCommands(commands.Cog):    def __init__(self, bot: commands.Bot):        self.bot = bot        self.earthquake_cache = {}        self.weather_cache = {}        self.weather_alert_cache = {}        self.reservoir_cache = {}        self.water_info_cache = {}  # æ–°å¢æ°´æƒ…è³‡æ–™å¿«å–        self.town_weather_cache = {}  # æ–°å¢é„‰é®å¤©æ°£å¿«å–        self.cache_time = 0        self.weather_cache_time = 0        self.weather_alert_cache_time = 0        self.reservoir_cache_time = 0        self.water_info_cache_time = 0  # æ–°å¢æ°´æƒ…è³‡æ–™å¿«å–æ™‚é–“        self.town_weather_cache_time = 0  # æ–°å¢é„‰é®å¤©æ°£å¿«å–æ™‚é–“        self.api_auth = "CWA-675CED45-09DF-4249-9599-B9B5A5AB761A"        self.notification_channels = {}        self.last_eq_time = {}        self.check_interval = 300  # æ¯5åˆ†é˜æª¢æŸ¥ä¸€æ¬¡                # å»ºç«‹ aiohttp å·¥ä½œéšæ®µ        self.session = None        self.bot.loop.create_task(self.init_aiohttp_session())                # é–‹å§‹åœ°éœ‡ç›£æ§        self.eq_check_task = self.bot.loop.create_task(self.check_earthquake_updates())    async def init_aiohttp_session(self):        """åˆå§‹åŒ– aiohttp å·¥ä½œéšæ®µ"""        # å»ºç«‹æ”¯æ´ SSL çš„é€£æ¥å™¨        connector = aiohttp.TCPConnector(            ssl=True,           # å•Ÿç”¨ SSL é©—è­‰            verify_ssl=True,    # é©—è­‰ SSL è­‰æ›¸            limit=10           # åŒæ™‚é€£æ¥æ•¸é™åˆ¶        )                # å»ºç«‹ aiohttp å·¥ä½œéšæ®µ        self.session = aiohttp.ClientSession(            timeout=aiohttp.ClientTimeout(total=20, connect=10, sock_read=15),            connector=connector        )        logger.info("å·²åˆå§‹åŒ– aiohttp å·¥ä½œéšæ®µ (SSLé©—è­‰å·²å•Ÿç”¨)")    async def cog_unload(self):        """ç•¶Cogè¢«å¸è¼‰æ™‚åœæ­¢åœ°éœ‡æª¢æŸ¥ä»»å‹™å’Œé—œé–‰aiohttpå·¥ä½œéšæ®µ"""        self.eq_check_task.cancel()        if self.session and not self.session.closed:            await self.session.close()            logger.info("å·²é—œé–‰ aiohttp å·¥ä½œéšæ®µ")    async def check_earthquake_updates(self):        """å®šæœŸæª¢æŸ¥æ˜¯å¦æœ‰æ–°åœ°éœ‡"""        await self.bot.wait_until_ready()        while not self.bot.is_closed():            try:                # æª¢æŸ¥ä¸€èˆ¬åœ°éœ‡                data = await self.fetch_earthquake_data(small_area=False)                if data and 'records' in data and 'earthquake' in data['records']:                    latest_eq = data['records']['earthquake'][0]                    report_time = latest_eq['reportTime']                                        # æª¢æŸ¥æ˜¯å¦ç‚ºæ–°åœ°éœ‡                    for guild_id, channel_id in self.notification_channels.items():                        if guild_id not in self.last_eq_time or report_time != self.last_eq_time[guild_id]:                            # æ›´æ–°æœ€å¾Œåœ°éœ‡æ™‚é–“                            self.last_eq_time[guild_id] = report_time                                                        # ç™¼é€é€šçŸ¥                            try:                                channel = self.bot.get_channel(channel_id)                                if channel:                                    embed = self.format_earthquake_data(data, small_area=False)                                    embed.title = "ğŸš¨ æ–°åœ°éœ‡é€šå ±ï¼"                                    await channel.send(embed=embed)                            except Exception as e:                                logger.error(f"ç™¼é€åœ°éœ‡é€šçŸ¥æ™‚ç™¼ç”ŸéŒ¯èª¤: {str(e)}")                            except asyncio.CancelledError:                # æ­£å¸¸å–æ¶ˆ                break            except Exception as e:                logger.error(f"æª¢æŸ¥åœ°éœ‡æ›´æ–°æ™‚ç™¼ç”ŸéŒ¯èª¤: {str(e)}")                        await asyncio.sleep(self.check_interval)    async def fetch_with_retry(self, url: str, timeout: int = 20, max_retries: int = 3) -> Optional[Dict[str, Any]]:        """ä»¥é‡è©¦æ©Ÿåˆ¶ç™¼é€éåŒæ­¥è«‹æ±‚"""        for attempt in range(max_retries):            try:                if self.session is None or self.session.closed:                    # å»ºç«‹æ–°çš„æœƒè©±æ™‚ç¦ç”¨SSLé©—è­‰                    connector = aiohttp.TCPConnector(ssl=False)                    self.session = aiohttp.ClientSession(                        timeout=aiohttp.ClientTimeout(total=timeout),                        connector=connector                    )                async with self.session.get(url, timeout=timeout) as response:                    if response.status == 200:                        return await response.json()                    else:                        logger.warning(f"APIè«‹æ±‚è¿”å›é200ç‹€æ…‹ç¢¼: {response.status}")                        return None            except asyncio.TimeoutError:                logger.error(f"APIè«‹æ±‚è¶…æ™‚ (å˜—è©¦ {attempt+1}/{max_retries})")                if attempt < max_retries - 1:                    await asyncio.sleep(1 * (attempt + 1))            except Exception as e:                logger.error(f"APIè«‹æ±‚éŒ¯èª¤ (å˜—è©¦ {attempt+1}/{max_retries}): {str(e)}")                if attempt < max_retries - 1:                    await asyncio.sleep(1 * (attempt + 1))                if attempt == max_retries - 1:                    # æœ€å¾Œä¸€æ¬¡å˜—è©¦å¤±æ•—æ™‚ï¼Œè¨˜éŒ„è©³ç´°éŒ¯èª¤                    logger.error(f"æœ€çµ‚APIè«‹æ±‚å¤±æ•—: {str(e)}")        return None    async def fetch_earthquake_data(self, small_area: bool = False) -> Optional[Dict[str, Any]]:        """å¾æ°£è±¡å±€å–å¾—æœ€æ–°åœ°éœ‡è³‡æ–™ (ä½¿ç”¨éåŒæ­¥è«‹æ±‚)"""        current_time = datetime.datetime.now().timestamp()        cache_key = "small" if small_area else "normal"                # å¦‚æœå¿«å–è³‡æ–™æœªéæœŸï¼ˆ5åˆ†é˜å…§ï¼‰ï¼Œç›´æ¥è¿”å›å¿«å–        if (cache_key in self.earthquake_cache and             current_time - self.cache_time < 300):            logger.info(f"ä½¿ç”¨å¿«å–çš„åœ°éœ‡è³‡æ–™ (é¡å‹: {cache_key})")            return self.earthquake_cache[cache_key]        try:            # é¸æ“‡é©ç•¶çš„ API ç«¯é»            if small_area:                url = f"https://opendata.cwa.gov.tw/api/v1/rest/datastore/E-A0016-001?Authorization={self.api_auth}"            else:                url = f"https://opendata.cwa.gov.tw/api/v1/rest/datastore/E-A0015-001?Authorization={self.api_auth}"                        # ä½¿ç”¨éåŒæ­¥è«‹æ±‚ç²å–è³‡æ–™            data = await self.fetch_with_retry(url, timeout=15, max_retries=3)                        if data:                # æ›´æ–°å¿«å–                self.earthquake_cache[cache_key] = data                self.cache_time = current_time                logger.info(f"æˆåŠŸç²å–ä¸¦æ›´æ–°åœ°éœ‡è³‡æ–™å¿«å–")                return data            else:                # å¦‚æœè«‹æ±‚å¤±æ•—ï¼Œæª¢æŸ¥æ˜¯å¦æœ‰å¿«å–è³‡æ–™å¯ç”¨                if cache_key in self.earthquake_cache:                    logger.warning("åœ°éœ‡è³‡æ–™è«‹æ±‚å¤±æ•—ï¼Œä½¿ç”¨éæœŸçš„å¿«å–è³‡æ–™")                    return self.earthquake_cache[cache_key]                return None                    except Exception as e:            logger.error(f"ç²å–åœ°éœ‡è³‡æ–™æ™‚ç™¼ç”ŸéŒ¯èª¤: {str(e)}")                        # å¦‚æœç™¼ç”ŸéŒ¯èª¤ï¼Œæª¢æŸ¥æ˜¯å¦æœ‰å¿«å–è³‡æ–™å¯ç”¨            if cache_key in self.earthquake_cache:                logger.info("ç™¼ç”ŸéŒ¯èª¤ï¼Œä½¿ç”¨åœ°éœ‡å¿«å–è³‡æ–™")                return self.earthquake_cache[cache_key]                        return None    async def fetch_weather_data(self) -> Optional[Dict[str, Any]]:        """å¾æ°£è±¡å±€å–å¾—36å°æ™‚å¤©æ°£é å ±è³‡æ–™ (ä½¿ç”¨éåŒæ­¥è«‹æ±‚)"""        current_time = datetime.datetime.now().timestamp()                # å¦‚æœå¿«å–è³‡æ–™æœªéæœŸï¼ˆ30åˆ†é˜å…§ï¼‰ï¼Œç›´æ¥è¿”å›å¿«å–        if (self.weather_cache and             current_time - self.weather_cache_time < 1800):            logger.info("ä½¿ç”¨å¿«å–çš„å¤©æ°£é å ±è³‡æ–™")            return self.weather_cache        try:            url = f"https://opendata.cwa.gov.tw/api/v1/rest/datastore/F-C0032-001?Authorization={self.api_auth}"                        # ä½¿ç”¨éåŒæ­¥è«‹æ±‚ç²å–è³‡æ–™            data = await self.fetch_with_retry(url, timeout=15, max_retries=3)                        if data:                # æ›´æ–°å¿«å–                self.weather_cache = data                self.weather_cache_time = current_time                logger.info("æˆåŠŸç²å–ä¸¦æ›´æ–°å¤©æ°£é å ±è³‡æ–™å¿«å–")                return data            else:                # å¦‚æœè«‹æ±‚å¤±æ•—ï¼Œæª¢æŸ¥æ˜¯å¦æœ‰å¿«å–è³‡æ–™å¯ç”¨                if self.weather_cache:                    logger.warning("å¤©æ°£è³‡æ–™è«‹æ±‚å¤±æ•—ï¼Œä½¿ç”¨éæœŸçš„å¿«å–è³‡æ–™")                    return self.weather_cache                return None                        except Exception as e:            logger.error(f"ç²å–å¤©æ°£é å ±è³‡æ–™æ™‚ç™¼ç”ŸéŒ¯èª¤: {str(e)}")                        # å¦‚æœç™¼ç”ŸéŒ¯èª¤ï¼Œæª¢æŸ¥æ˜¯å¦æœ‰å¿«å–è³‡æ–™å¯ç”¨            if self.weather_cache:                logger.info("ç™¼ç”ŸéŒ¯èª¤ï¼Œä½¿ç”¨å¤©æ°£é å ±å¿«å–è³‡æ–™")                return self.weather_cache                            return None    async def fetch_reservoir_data(self) -> Optional[Dict[str, Any]]:        """å¾æ°´åˆ©ç½²å–å¾—æœ€æ–°æ°´åº«è³‡æ–™ (ä½¿ç”¨éåŒæ­¥è«‹æ±‚)"""        current_time = datetime.datetime.now().timestamp()                # å¦‚æœå¿«å–è³‡æ–™æœªéæœŸï¼ˆ30åˆ†é˜å…§ï¼‰ï¼Œç›´æ¥è¿”å›å¿«å–        if (self.reservoir_cache and             current_time - self.reservoir_cache_time < 1800):            logger.info("ä½¿ç”¨å¿«å–çš„æ°´åº«è³‡æ–™")            return self.reservoir_cache        try:            url = "https://data.wra.gov.tw/OpenAPI/api/OpenData/50C8256D-30C5-4B8D-9B84-2E14D5C6DF71/Data?size=1000&page=1"                        # ä½¿ç”¨éåŒæ­¥è«‹æ±‚ç²å–è³‡æ–™            data = await self.fetch_with_retry(url, timeout=20, max_retries=3)                        if data:                # æ›´æ–°å¿«å–                self.reservoir_cache = data                self.reservoir_cache_time = current_time                logger.info("æˆåŠŸç²å–ä¸¦æ›´æ–°æ°´åº«è³‡æ–™å¿«å–")                return data            else:                # å¦‚æœè«‹æ±‚å¤±æ•—ï¼Œæª¢æŸ¥æ˜¯å¦æœ‰å¿«å–è³‡æ–™å¯ç”¨                if self.reservoir_cache:                    logger.warning("æ°´åº«è³‡æ–™è«‹æ±‚å¤±æ•—ï¼Œä½¿ç”¨éæœŸçš„å¿«å–è³‡æ–™")                    return self.reservoir_cache                return None                        except Exception as e:            logger.error(f"ç²å–æ°´åº«è³‡æ–™æ™‚ç™¼ç”ŸéŒ¯èª¤: {str(e)}")                        # å¦‚æœç™¼ç”ŸéŒ¯èª¤ï¼Œæª¢æŸ¥æ˜¯å¦æœ‰å¿«å–è³‡æ–™å¯ç”¨            if self.reservoir_cache:                logger.info("ç™¼ç”ŸéŒ¯èª¤ï¼Œä½¿ç”¨æ°´åº«è³‡æ–™å¿«å–")                return self.reservoir_cache                            return None    async def fetch_water_info_data(self) -> Optional[Dict[str, Any]]:        """å¾æ°´åˆ©ç½²å–å¾—æœ€æ–°æ°´åº«æ°´æƒ…è³‡æ–™ (ä½¿ç”¨éåŒæ­¥è«‹æ±‚)"""        current_time = datetime.datetime.now().timestamp()                # å¦‚æœå¿«å–è³‡æ–™æœªéæœŸï¼ˆ30åˆ†é˜å…§ï¼‰ï¼Œç›´æ¥è¿”å›å¿«å–        if (self.water_info_cache and             current_time - self.water_info_cache_time < 1800):            logger.info("ä½¿ç”¨å¿«å–çš„æ°´åº«æ°´æƒ…è³‡æ–™")            return self.water_info_cache        try:            # è¨­å®šAPIç«¯é»            url = "https://data.wra.gov.tw/OpenAPI/api/OpenData/1602CA19-B224-4CC3-AA31-11B1B124530F/Data?size=1000&page=1"                        # ä½¿ç”¨å¢å¼·ç‰ˆçš„éåŒæ­¥è«‹æ±‚æ–¹æ³•ï¼Œå¢åŠ è¶…æ™‚æ™‚é–“å’Œé‡è©¦æ¬¡æ•¸            data = None                        # é¦–æ¬¡å˜—è©¦ä½¿ç”¨æ¨™æº–è¶…æ™‚è¨­å®š            try:                async with asyncio.timeout(30):  # å¢åŠ ç¸½è¶…æ™‚æ™‚é–“åˆ°30ç§’                    data = await self.fetch_with_retry(url, timeout=25, max_retries=5)            except asyncio.TimeoutError:                logger.warning("ç¬¬ä¸€æ¬¡ç²å–æ°´åº«æ°´æƒ…è³‡æ–™è¶…æ™‚ï¼Œå°‡å˜—è©¦é™ç´šè«‹æ±‚")                # å¦‚æœç¬¬ä¸€æ¬¡è¶…æ™‚ï¼Œå˜—è©¦ä½¿ç”¨æ›´å¯¬é¬†çš„è¶…æ™‚è¨­å®š                try:                    # å‰µå»ºæ–°çš„æœƒè©±ä¸¦è¨­å®šæ›´å¯¬é¬†çš„è¶…æ™‚                    async with aiohttp.ClientSession(                        timeout=aiohttp.ClientTimeout(total=40, connect=20, sock_read=30),                        connector=aiohttp.TCPConnector(verify_ssl=False)                    ) as session:                        async with session.get(url) as response:                            if response.status == 200:                                data = await response.json()                                logger.info("é€éé™ç´šè«‹æ±‚æˆåŠŸç²å–æ°´åº«æ°´æƒ…è³‡æ–™")                            else:                                logger.error(f"é™ç´šè«‹æ±‚å¤±æ•—: HTTPç‹€æ…‹ç¢¼ {response.status}")                except Exception as e:                    logger.error(f"é™ç´šè«‹æ±‚æ™‚ç™¼ç”ŸéŒ¯èª¤: {str(e)}")                        if data:                # é©—è­‰æ•¸æ“šçµæ§‹                if 'responseData' in data and isinstance(data['responseData'], list):                    # å¢å¼·æ•¸æ“šé©—è­‰: æª¢æŸ¥ç¬¬ä¸€å€‹é …ç›®æ˜¯å¦åŒ…å«å¿…è¦å­—æ®µ                    if data['responseData'] and isinstance(data['responseData'][0], dict) and 'ReservoirName' in data['responseData'][0]:                        # æ›´æ–°å¿«å–                        self.water_info_cache = data                        self.water_info_cache_time = current_time                        logger.info("æˆåŠŸç²å–ä¸¦æ›´æ–°æ°´åº«æ°´æƒ…è³‡æ–™å¿«å–")                        return data                    else:                        logger.error("æ°´åº«æ°´æƒ…è³‡æ–™çµæ§‹ç„¡æ•ˆ: è³‡æ–™é …ç›®ç¼ºå°‘å¿…è¦å­—æ®µ")                else:                    logger.error(f"æ°´åº«æ°´æƒ…æ•¸æ“šæ ¼å¼ç•°å¸¸: {list(data.keys()) if isinstance(data, dict) else 'éå­—å…¸é¡å‹'}")                                # å³ä½¿æ•¸æ“šçµæ§‹ä¸å®Œæ•´ï¼Œä¹Ÿè¿”å›ç²å–åˆ°çš„æ•¸æ“šï¼Œé¿å…å®Œå…¨å¤±æ•—                logger.warning("æ°´åº«æ°´æƒ…æ•¸æ“šçµæ§‹ç•°å¸¸ï¼Œä½†ä»è¿”å›ç²å–åˆ°çš„æ•¸æ“š")                return data            else:                # å¦‚æœè«‹æ±‚å¤±æ•—ï¼Œæª¢æŸ¥æ˜¯å¦æœ‰å¿«å–è³‡æ–™å¯ç”¨                if self.water_info_cache:                    logger.warning("æ°´åº«æ°´æƒ…è«‹æ±‚å¤±æ•—ï¼Œä½¿ç”¨éæœŸçš„å¿«å–è³‡æ–™")                    return self.water_info_cache                else:                    logger.error("ç„¡æ³•ç²å–æ°´åº«æ°´æƒ…è³‡æ–™ï¼Œä¸”æ²’æœ‰å¯ç”¨çš„å¿«å–")                return None                        except asyncio.TimeoutError:            logger.error("ç²å–æ°´åº«æ°´æƒ…è³‡æ–™è¶…æ™‚")            # ç›´æ¥ä½¿ç”¨å¿«å–ï¼Œé¿å…å†æ¬¡å˜—è©¦å¯èƒ½æœƒè¶…æ™‚çš„è«‹æ±‚            if self.water_info_cache:                logger.info("ç™¼ç”Ÿè¶…æ™‚ï¼Œä½¿ç”¨æ°´åº«æ°´æƒ…å¿«å–è³‡æ–™")                return self.water_info_cache            return None                        except Exception as e:            logger.error(f"ç²å–æ°´åº«æ°´æƒ…è³‡æ–™æ™‚ç™¼ç”ŸéŒ¯èª¤: {str(e)}")                        # å¦‚æœç™¼ç”ŸéŒ¯èª¤ï¼Œæª¢æŸ¥æ˜¯å¦æœ‰å¿«å–è³‡æ–™å¯ç”¨            if self.water_info_cache:                logger.info("ç™¼ç”ŸéŒ¯èª¤ï¼Œä½¿ç”¨æ°´åº«æ°´æƒ…å¿«å–è³‡æ–™")                return self.water_info_cache                            return None    async def fetch_town_weather_data(self) -> Optional[Dict[str, Any]]:        """å¾æ°£è±¡å±€å–å¾—é„‰é®å¤©æ°£é å ±è³‡æ–™"""        current_time = datetime.datetime.now().timestamp()                # å¦‚æœå¿«å–è³‡æ–™æœªéæœŸï¼ˆ30åˆ†é˜å…§ï¼‰ï¼Œç›´æ¥è¿”å›å¿«å–        if (self.town_weather_cache and             current_time - self.town_weather_cache_time < 1800):            logger.info("ä½¿ç”¨å¿«å–çš„é„‰é®å¤©æ°£é å ±è³‡æ–™")            return self.town_weather_cache        try:            url = f"https://opendata.cwa.gov.tw/api/v1/rest/datastore/F-D0047-093?Authorization={self.api_auth}&locationId=F-D0047-001"                        # ä½¿ç”¨éåŒæ­¥è«‹æ±‚ç²å–è³‡æ–™            data = await self.fetch_with_retry(url, timeout=20, max_retries=3)                        if data:                # æ›´æ–°å¿«å–                self.town_weather_cache = data                self.town_weather_cache_time = current_time                logger.info("æˆåŠŸç²å–ä¸¦æ›´æ–°é„‰é®å¤©æ°£é å ±è³‡æ–™å¿«å–")                return data            else:                # å¦‚æœè«‹æ±‚å¤±æ•—ï¼Œæª¢æŸ¥æ˜¯å¦æœ‰å¿«å–è³‡æ–™å¯ç”¨                if self.town_weather_cache:                    logger.warning("é„‰é®å¤©æ°£è³‡æ–™è«‹æ±‚å¤±æ•—ï¼Œä½¿ç”¨éæœŸçš„å¿«å–è³‡æ–™")                    return self.town_weather_cache                return None                        except Exception as e:            logger.error(f"ç²å–é„‰é®å¤©æ°£é å ±è³‡æ–™æ™‚ç™¼ç”ŸéŒ¯èª¤: {str(e)}")                        # å¦‚æœç™¼ç”ŸéŒ¯èª¤ï¼Œæª¢æŸ¥æ˜¯å¦æœ‰å¿«å–è³‡æ–™å¯ç”¨            if self.town_weather_cache:                logger.info("ç™¼ç”ŸéŒ¯èª¤ï¼Œä½¿ç”¨é„‰é®å¤©æ°£é å ±å¿«å–è³‡æ–™")                return self.town_weather_cache                            return None    def format_reservoir_data(self, data: Dict[str, Any], reservoir_name: str) -> discord.Embed:        """æ ¼å¼åŒ–æ°´åº«è³‡æ–™ç‚º Discord åµŒå…¥æ¶ˆæ¯"""        try:            # æª¢æŸ¥è³‡æ–™çµæ§‹ï¼Œé©æ‡‰å¯èƒ½çš„APIè®ŠåŒ–            reservoirs = None                        # æª¢æŸ¥èˆŠæ ¼å¼ (æœ‰dataæ¬„ä½)            if 'data' in data:                reservoirs = data['data']            # æª¢æŸ¥å¯èƒ½çš„æ–°æ ¼å¼            elif 'ReservoirConditionsToday' in data:                reservoirs = data['ReservoirConditionsToday']            elif 'ReservoirInfo' in data:                reservoirs = data['ReservoirInfo']            elif isinstance(data, list):  # å¯èƒ½ç›´æ¥æ˜¯åˆ—è¡¨æ ¼å¼                reservoirs = data            else:                # å˜—è©¦æ‰¾å‡ºè³‡æ–™ä¸­å¯èƒ½åŒ…å«æ°´åº«è³‡è¨Šçš„æ¬„ä½                for key, value in data.items():                    if isinstance(value, list) and len(value) > 0:                        # æª¢æŸ¥ç¬¬ä¸€å€‹å…ƒç´ æ˜¯å¦åƒæ°´åº«è³‡æ–™ (æœ‰ ReservoirName æ¬„ä½)                        if isinstance(value[0], dict) and 'ReservoirName' in value[0]:                            reservoirs = value                            logger.info(f"æ‰¾åˆ°å¯èƒ½çš„æ°´åº«è³‡æ–™æ¬„ä½: {key}")                            break                        if not reservoirs:                logger.error(f"ç„¡æ³•è¾¨è­˜æ°´åº«è³‡æ–™æ ¼å¼. è³‡æ–™çµæ§‹: {data.keys() if isinstance(data, dict) else type(data)}")                return discord.Embed(                    title="âš ï¸ è³‡æ–™æ ¼å¼éŒ¯èª¤",                    description="ç›®å‰ç„¡æ³•è§£ææ°´åº«è³‡æ–™æ ¼å¼ï¼Œè«‹é€šçŸ¥ç®¡ç†å“¡æª¢æŸ¥APIè®Šæ›´",                    color=discord.Color.orange()                )                        if not reservoirs:                return discord.Embed(                    title="âš ï¸ æ²’æœ‰æ°´åº«è³‡æ–™",                    description="ç›®å‰æ²’æœ‰ä»»ä½•æ°´åº«è³‡æ–™å¯ä¾›é¡¯ç¤º",                    color=discord.Color.orange()                )                        # å°‹æ‰¾æŒ‡å®šæ°´åº«çš„è³‡æ–™            reservoir_data = None            for reservoir in reservoirs:                if reservoir.get('ReservoirName') == reservoir_name:                    reservoir_data = reservoir                    break                        if not reservoir_data:                return discord.Embed(                    title="âŒ æ‰¾ä¸åˆ°è³‡æ–™",                    description=f"æ‰¾ä¸åˆ° {reservoir_name} çš„è³‡æ–™",                    color=discord.Color.red()                )                        # è§£ææ°´åº«è³‡æ–™            name = reservoir_data.get('ReservoirName', 'ç„¡è³‡æ–™')            time = reservoir_data.get('ObservationTime', reservoir_data.get('DataTime', 'ç„¡è³‡æ–™'))            capacity = reservoir_data.get('EffectiveCapacity', reservoir_data.get('Capacity', 'ç„¡è³‡æ–™'))  # æœ‰æ•ˆå®¹é‡            current_volume = reservoir_data.get('EffectiveWaterStorageCapacity', reservoir_data.get('WaterStorage', 'ç„¡è³‡æ–™'))  # æœ‰æ•ˆè“„æ°´é‡            percentage = reservoir_data.get('PercentageOfStorage', reservoir_data.get('CapacityPercentage', 'ç„¡è³‡æ–™'))  # è“„æ°´ç™¾åˆ†æ¯”            inflow = reservoir_data.get('InflowVolume', reservoir_data.get('Inflow', 'ç„¡è³‡æ–™'))  # é€²æ°´é‡            outflow = reservoir_data.get('OutflowTotal', reservoir_data.get('Outflow', 'ç„¡è³‡æ–™'))  # å‡ºæ°´é‡                        # è™•ç†ç™¾åˆ†æ¯”æ ¼å¼ï¼Œç¢ºä¿é¡¯ç¤ºç‚ºæ•¸å­—            if percentage and percentage != 'ç„¡è³‡æ–™':                try:                    # å˜—è©¦å°‡ç™¾åˆ†æ¯”è½‰æ›ç‚ºæµ®é»æ•¸                    percentage = float(percentage)                    # æª¢æŸ¥æ˜¯å¦å·²ç¶“æ˜¯å°æ•¸å½¢å¼ (ä¾‹å¦‚0.75ä»£è¡¨75%)                    if percentage < 1.0:                        percentage = percentage * 100                    # æ ¼å¼åŒ–ç‚ºæœ€å¤š2ä½å°æ•¸                    percentage = f"{percentage:.2f}".rstrip('0').rstrip('.') if '.' in f"{percentage:.2f}" else f"{percentage:.0f}"                except ValueError:                    # å¦‚æœç„¡æ³•è½‰æ›ï¼Œä¿æŒåŸæ¨£                    pass                        # è¨ˆç®—æ°´æƒ…ç‹€æ…‹            water_status = "æ­£å¸¸"            status_color = discord.Color.green()            status_emoji = "âœ…"                        if percentage and percentage != 'ç„¡è³‡æ–™':                try:                    percent_float = float(percentage)                    if percent_float < 20:                        water_status = "åš´é‡æ°´æƒ…"                        status_color = discord.Color.red()                        status_emoji = "âš ï¸"                    elif percent_float < 30:                        water_status = "æ°´æƒ…è­¦æˆ’"                        status_color = discord.Color.orange()                        status_emoji = "âš ï¸"                    elif percent_float < 50:                        water_status = "æ°´æƒ…æé†’"                        status_color = discord.Color.gold()                        status_emoji = "âš ï¸"                    elif percent_float < 70:                        water_status = "æ°´æƒ…æ³¨æ„"                        status_color = discord.Color.blue()                        status_emoji = "â„¹ï¸"                    elif percent_float >= 90:                        water_status = "æ°´æƒ…å……è£•"                        status_color = discord.Color.dark_green()                        status_emoji = "ğŸ’¯"                except ValueError:                    # å¦‚æœç„¡æ³•è½‰æ›ç™¾åˆ†æ¯”ï¼Œä½¿ç”¨é è¨­å€¼                    pass                        # å»ºç«‹åµŒå…¥æ¶ˆæ¯            embed = discord.Embed(                title=f"ğŸ’§ {name} æ°´åº«æ¯æ—¥ç‡Ÿé‹æƒ…æ³",                description=f"è§€æ¸¬æ™‚é–“: {time}",                color=status_color            )                        embed.add_field(                name="ğŸ“Š è“„æ°´é‡",                value=f"ç›®å‰è“„æ°´é‡: {current_volume} è¬ç«‹æ–¹å…¬å°º\n"                      f"æœ‰æ•ˆå®¹é‡: {capacity} è¬ç«‹æ–¹å…¬å°º\n"                      f"è“„æ°´ç™¾åˆ†æ¯”: {percentage}%",                inline=False            )                        embed.add_field(                name="ğŸŒŠ é€²å‡ºæ°´é‡",                value=f"é€²æ°´é‡: {inflow} ç«‹æ–¹å…¬å°º/ç§’\n"                      f"å‡ºæ°´é‡: {outflow} ç«‹æ–¹å…¬å°º/ç§’",                inline=False            )                        embed.add_field(                name=f"{status_emoji} æ°´æƒ…ç‹€æ…‹",                value=water_status,                inline=False            )                        # æ·»åŠ è³‡æ–™ä¾†æº            embed.set_footer(text=f"è³‡æ–™ä¾†æº: ç¶“æ¿Ÿéƒ¨æ°´åˆ©ç½²")                        return embed                    except ValueError as ve:            logger.error(f"æ ¼å¼åŒ–æ°´åº«è³‡æ–™æ™‚ç™¼ç”ŸéŒ¯èª¤: {str(ve)}")            return discord.Embed(                title="âŒ è³‡æ–™æ ¼å¼éŒ¯èª¤",                description=f"ç„¡æ³•è§£ææ°´åº«è³‡æ–™: {str(ve)}",                color=discord.Color.red()            )                    except Exception as e:            logger.error(f"æ ¼å¼åŒ–æ°´åº«è³‡æ–™æ™‚ç™¼ç”ŸéŒ¯èª¤: {str(e)}")            return discord.Embed(                title="âŒ éŒ¯èª¤",                description="æ ¼å¼åŒ–æ°´åº«è³‡æ–™æ™‚ç™¼ç”ŸéŒ¯èª¤ï¼Œè«‹ç¨å¾Œå†è©¦",                color=discord.Color.red()            )    def format_water_info_data(self, data: Dict[str, Any], reservoir_name: str) -> discord.Embed:        """æ ¼å¼åŒ–æ°´åº«æ°´æƒ…è³‡æ–™ç‚º Discord åµŒå…¥æ¶ˆæ¯"""        try:            # æª¢æŸ¥è³‡æ–™çµæ§‹            if not data or 'responseData' not in data:                logger.error(f"ç„¡æ•ˆçš„æ°´åº«æ°´æƒ…è³‡æ–™æ ¼å¼: ç¼ºå°‘ responseData æ¬„ä½")                return discord.Embed(                    title="âš ï¸ è³‡æ–™æ ¼å¼éŒ¯èª¤",                    description="ç„¡æ³•è®€å–æ°´åº«æ°´æƒ…è³‡æ–™ï¼Œè«‹é€šçŸ¥ç®¡ç†å“¡æª¢æŸ¥APIè®Šæ›´",                    color=discord.Color.orange()                )                        reservoirs = data.get('responseData', [])                        if not reservoirs:                return discord.Embed(                    title="âš ï¸ æ²’æœ‰æ°´åº«æ°´æƒ…è³‡æ–™",                    description="ç›®å‰æ²’æœ‰ä»»ä½•æ°´åº«æ°´æƒ…è³‡æ–™å¯ä¾›é¡¯ç¤º",                    color=discord.Color.orange()                )                        # å°‹æ‰¾æŒ‡å®šæ°´åº«çš„è³‡æ–™            reservoir_data = None            for reservoir in reservoirs:                if reservoir.get('ReservoirName') == reservoir_name:                    reservoir_data = reservoir                    break                        if not reservoir_data:                return discord.Embed(                    title="âŒ æ‰¾ä¸åˆ°è³‡æ–™",                    description=f"æ‰¾ä¸åˆ° {reservoir_name} çš„æ°´æƒ…è³‡æ–™",                    color=discord.Color.red()                )                        # è§£ææ°´åº«æ°´æƒ…è³‡æ–™            name = reservoir_data.get('ReservoirName', 'ç„¡è³‡æ–™')            time = reservoir_data.get('ObservationTime', 'ç„¡è³‡æ–™')            water_level = reservoir_data.get('WaterLevel', 'ç„¡è³‡æ–™')  # æ°´ä½é«˜åº¦            effective_capacity = reservoir_data.get('EffectiveCapacity', 'ç„¡è³‡æ–™')  # æœ‰æ•ˆå®¹é‡            effective_storage = reservoir_data.get('EffectiveStorage', 'ç„¡è³‡æ–™')  # æœ‰æ•ˆè“„æ°´é‡            percentage = reservoir_data.get('PercentageOfStorage', 'ç„¡è³‡æ–™')  # è“„æ°´ç™¾åˆ†æ¯”            inflow = reservoir_data.get('InFlow', 'ç„¡è³‡æ–™')  # é€²æ°´é‡            outflow = reservoir_data.get('OutFlow', 'ç„¡è³‡æ–™')  # å‡ºæ°´é‡                        # è™•ç†ç™¾åˆ†æ¯”æ ¼å¼ï¼Œç¢ºä¿é¡¯ç¤ºç‚ºæ•¸å­—            if percentage and percentage != 'ç„¡è³‡æ–™':                try:                    # å˜—è©¦å°‡ç™¾åˆ†æ¯”è½‰æ›ç‚ºæµ®é»æ•¸                    percentage = float(percentage)                    # æª¢æŸ¥æ˜¯å¦å·²ç¶“æ˜¯å°æ•¸å½¢å¼ (ä¾‹å¦‚0.75ä»£è¡¨75%)                    if percentage < 1.0:                        percentage = percentage * 100                    # æ ¼å¼åŒ–ç‚ºæœ€å¤š2ä½å°æ•¸                    percentage = f"{percentage:.2f}".rstrip('0').rstrip('.') if '.' in f"{percentage:.2f}" else f"{percentage:.0f}"                except ValueError:                    # å¦‚æœç„¡æ³•è½‰æ›ï¼Œä¿æŒåŸæ¨£                    pass                        # è¨ˆç®—æ°´æƒ…ç‹€æ…‹            water_status = "æ­£å¸¸"            status_color = discord.Color.green()            status_emoji = "âœ…"                        if percentage and percentage != 'ç„¡è³‡æ–™':                try:                    percent_float = float(percentage)                    if percent_float < 20:                        water_status = "åš´é‡æ°´æƒ…"                        status_color = discord.Color.red()                        status_emoji = "ğŸ”´"                    elif percent_float < 30:                        water_status = "æ°´æƒ…è­¦æˆ’"                        status_color = discord.Color.orange()                        status_emoji = "ğŸŸ "                    elif percent_float < 50:                        water_status = "æ°´æƒ…æé†’"                        status_color = discord.Color.gold()                        status_emoji = "ğŸŸ¡"                    elif percent_float < 70:                        water_status = "æ°´æƒ…æ³¨æ„"                        status_color = discord.Color.blue()                        status_emoji = "ğŸ”µ"                    elif percent_float >= 90:                        water_status = "æ°´æƒ…å……è£•"                        status_color = discord.Color.dark_green()                        status_emoji = "ğŸŸ¢"                except ValueError:                    # å¦‚æœç„¡æ³•è½‰æ›ç™¾åˆ†æ¯”ï¼Œä½¿ç”¨é è¨­å€¼                    pass                        # å»ºç«‹åµŒå…¥æ¶ˆæ¯            embed = discord.Embed(                title=f"ğŸ’§ {name} æ°´åº«æ°´æƒ…è³‡æ–™",                description=f"è§€æ¸¬æ™‚é–“: {time}",                color=status_color            )                        embed.add_field(                name="ğŸ“Š æ°´åº«æ°´ä½",                value=f"ç›®å‰æ°´ä½: {water_level} å…¬å°º",                inline=False            )                        embed.add_field(                name="ğŸŒŠ è“„æ°´æƒ…æ³",                value=f"æœ‰æ•ˆå®¹é‡: {effective_capacity} è¬ç«‹æ–¹å…¬å°º\n"                      f"æœ‰æ•ˆè“„æ°´é‡: {effective_storage} è¬ç«‹æ–¹å…¬å°º\n"                      f"è“„æ°´ç™¾åˆ†æ¯”: {percentage}%",                inline=False            )                        embed.add_field(                name="ğŸ”„ é€²å‡ºæ°´é‡",                value=f"é€²æ°´é‡: {inflow} cms\n"                      f"å‡ºæ°´é‡: {outflow} cms",                inline=False            )                        embed.add_field(                name=f"{status_emoji} æ°´æƒ…ç‹€æ…‹",                value=water_status,                inline=False            )                        # æ·»åŠ è³‡æ–™ä¾†æº            embed.set_footer(text=f"è³‡æ–™ä¾†æº: ç¶“æ¿Ÿéƒ¨æ°´åˆ©ç½²")                        return embed                    except Exception as e:            logger.error(f"æ ¼å¼åŒ–æ°´åº«æ°´æƒ…è³‡æ–™æ™‚ç™¼ç”ŸéŒ¯èª¤: {str(e)}")            return discord.Embed(                title="âŒ éŒ¯èª¤",                description="æ ¼å¼åŒ–æ°´åº«æ°´æƒ…è³‡æ–™æ™‚ç™¼ç”ŸéŒ¯èª¤ï¼Œè«‹ç¨å¾Œå†è©¦",                color=discord.Color.red()            )    def format_town_weather_data(self, data: Dict[str, Any], town_name: str) -> discord.Embed:        """æ ¼å¼åŒ–é„‰é®å¤©æ°£é å ±è³‡æ–™ç‚º Discord åµŒå…¥æ¶ˆæ¯"""        try:            # æª¢æŸ¥è³‡æ–™çµæ§‹            if 'records' not in data or 'locations' not in data['records']:                return discord.Embed(                    title="âŒ è³‡æ–™æ ¼å¼éŒ¯èª¤",                    description="ç„¡æ³•è§£æå¤©æ°£è³‡æ–™",                    color=discord.Color.red()                )            # å°‹æ‰¾æŒ‡å®šé„‰é®çš„è³‡æ–™            locations = data['records']['locations'][0]['location']            location_data = None            for loc in locations:                if loc['locationName'] == town_name:                    location_data = loc                    break            if not location_data:                return discord.Embed(                    title="âŒ æ‰¾ä¸åˆ°è³‡æ–™",                    description=f"æ‰¾ä¸åˆ° {town_name} çš„å¤©æ°£è³‡æ–™",                    color=discord.Color.red()                )            # æ•´ç†å¤©æ°£è¦ç´ è³‡æ–™            weather_elements = location_data['weatherElement']            forecast_data = {}                        # å®šç¾©è¦ç´ å°æ‡‰è¡¨            element_mapping = {                'Wx': 'å¤©æ°£ç¾è±¡',                'PoP12h': 'é™é›¨æ©Ÿç‡',                'T': 'æº«åº¦',                'RH': 'ç›¸å°æ¿•åº¦',                'CI': 'èˆ’é©åº¦'            }            # æ“·å–æœªä¾†24å°æ™‚çš„é å ±è³‡æ–™            current_time = datetime.datetime.now()            forecast_times = []                        for element in weather_elements:                element_name = element['elementName']                if element_name in element_mapping:                    for time_slot in element['time'][:8]:  # å–å‰8å€‹æ™‚æ®µï¼ˆç´„24å°æ™‚ï¼‰                        start_time = datetime.datetime.strptime(                            time_slot['startTime'],                            '%Y-%m-%d %H:%M:%S'                        )                        if start_time not in forecast_data:                            forecast_data[start_time] = {}                            forecast_times.append(start_time)                                                if element_name == 'Wx':                            forecast_data[start_time][element_mapping[element_name]] = time_slot['elementValue'][0]['value']                        elif element_name == 'PoP12h':                            # é™é›¨æ©Ÿç‡å¯èƒ½ç‚ºç©ºå€¼                            value = time_slot['elementValue'][0]['value']                            forecast_data[start_time][element_mapping[element_name]] = f"{value}%" if value else "ç„¡è³‡æ–™"                        elif element_name == 'T':                            forecast_data[start_time][element_mapping[element_name]] = f"{time_slot['elementValue'][0]['value']}Â°C"                        elif element_name == 'RH':                            # è½‰æ›ç‚ºç™¾åˆ†æ¯”                            rh_value = int(time_slot['elementValue'][0]['value'])                            forecast_data[start_time][element_mapping[element_name]] = f"{rh_value}%"                        else:                            forecast_data[start_time][element_mapping[element_name]] = time_slot['elementValue'][0]['value']            # å»ºç«‹åµŒå…¥æ¶ˆæ¯            embed = discord.Embed(                title=f"ğŸŒ¦ï¸ {town_name} å¤©æ°£é å ±",                description=f"è³‡æ–™æ›´æ–°æ™‚é–“: {current_time.strftime('%Y/%m/%d %H:%M')}",                color=discord.Color.blue()            )            # åŠ å…¥é å ±è³‡æ–™            for time in sorted(forecast_times)[:6]:  # åªé¡¯ç¤ºå‰6å€‹æ™‚æ®µ                time_str = time.strftime('%m/%d %H:%M')                weather_info = forecast_data[time]                value = (                    f"å¤©æ°£: {weather_info.get('å¤©æ°£ç¾è±¡', 'ç„¡è³‡æ–™')}\n"                    f"æº«åº¦: {weather_info.get('æº«åº¦', 'ç„¡è³‡æ–™')}\n"                    f"æ¿•åº¦: {weather_info.get('ç›¸å°æ¿•åº¦', 'ç„¡è³‡æ–™')}\n"                    f"é™é›¨æ©Ÿç‡: {weather_info.get('é™é›¨æ©Ÿç‡', 'ç„¡è³‡æ–™')}\n"                    f"é«”æ„Ÿ: {weather_info.get('èˆ’é©åº¦', 'ç„¡è³‡æ–™')}"                )                embed.add_field(                    name=time_str,                    value=value,                    inline=True                )            embed.set_footer(text="è³‡æ–™ä¾†æº: ä¸­å¤®æ°£è±¡ç½²")            return embed        except Exception as e:            logger.error(f"æ ¼å¼åŒ–é„‰é®å¤©æ°£è³‡æ–™æ™‚ç™¼ç”ŸéŒ¯èª¤: {str(e)}")            return discord.Embed(                title="âŒ éŒ¯èª¤",                description="æ ¼å¼åŒ–å¤©æ°£è³‡æ–™æ™‚ç™¼ç”ŸéŒ¯èª¤ï¼Œè«‹ç¨å¾Œå†è©¦",                color=discord.Color.red()            )    @app_commands.command(        name="weather",        description="æŸ¥è©¢åœ°å€36å°æ™‚å¤©æ°£é å ±"    )    async def weather(self, interaction: discord.Interaction):        """é–‹å•Ÿä¸€å€‹ä¸‹æ‹‰å¼é¸å–®ä¾†é¸æ“‡è¦æŸ¥è©¢çš„ç¸£å¸‚å¤©æ°£é å ±"""        try:            # å‰µå»ºä¸‹æ‹‰å¼é¸å–®è¦–åœ–            view = WeatherSelectView(self)                        # ç™¼é€é¸æ“‡æç¤ºè¨Šæ¯            embed = discord.Embed(                title="ğŸŒ¤ï¸ å¤©æ°£æŸ¥è©¢",                description="è«‹å¾ä¸‹æ–¹é¸å–®é¸æ“‡è¦æŸ¥è©¢çš„ç¸£å¸‚",                color=discord.Color.blue()            )                        embed.add_field(                name="ğŸ“‹ å¤©æ°£è³‡è¨ŠåŒ…å«",                value="â€¢ æœªä¾†36å°æ™‚å¤©æ°£é å ±\nâ€¢ é™é›¨æ©Ÿç‡\nâ€¢ æº«åº¦ç¯„åœ\nâ€¢ èˆ’é©åº¦æŒ‡æ•¸",                inline=False            )                        embed.add_field(                name="â±ï¸ é¸å–®æœ‰æ•ˆæ™‚é–“",                value="æ­¤é¸å–®å°‡åœ¨2åˆ†é˜å¾Œè‡ªå‹•å¤±æ•ˆ",                inline=False            )                        embed.set_footer(text="è³‡æ–™ä¾†æºï¼šäº¤é€šéƒ¨ä¸­å¤®æ°£è±¡ç½²")                        await interaction.response.send_message(embed=embed, view=view)                    except Exception as e:            logger.error(f"å‰µå»ºå¤©æ°£æŸ¥è©¢é¸å–®æ™‚ç™¼ç”ŸéŒ¯èª¤: {str(e)}")            await interaction.response.send_message(                embed=discord.Embed(                    title="âŒ éŒ¯èª¤",                    description="ç„¡æ³•é¡¯ç¤ºå¤©æ°£æŸ¥è©¢é¸å–®ï¼Œè«‹ç¨å¾Œå†è©¦",                    color=discord.Color.red()                ),                ephemeral=True            )    @app_commands.command(        name="reservoir",        description="æŸ¥è©¢æ°´åº«æ¯æ—¥ç‡Ÿé‹æƒ…æ³"    )    async def reservoir(self, interaction: discord.Interaction):        """é–‹å•Ÿä¸€å€‹ä¸‹æ‹‰å¼é¸å–®ä¾†é¸æ“‡è¦æŸ¥è©¢çš„æ°´åº«ç‡Ÿé‹æƒ…æ³"""        try:            # å‰µå»ºä¸‹æ‹‰å¼é¸å–®è¦–åœ–            view = ReservoirSelectView(self)                        # ç™¼é€é¸æ“‡æç¤ºè¨Šæ¯            embed = discord.Embed(                title="ğŸ’§ æ°´åº«ç‡Ÿé‹æƒ…æ³æŸ¥è©¢",                description="è«‹å¾ä¸‹æ–¹é¸å–®é¸æ“‡è¦æŸ¥è©¢çš„æ°´åº«",                color=discord.Color.blue()            )                        embed.add_field(                name="ğŸ“‹ æ°´åº«è³‡è¨ŠåŒ…å«",                value="â€¢ ç›®å‰è“„æ°´é‡\nâ€¢ æœ‰æ•ˆå®¹é‡\nâ€¢ è“„æ°´ç™¾åˆ†æ¯”\nâ€¢ é€²å‡ºæ°´é‡\nâ€¢ æ°´æƒ…ç‹€æ…‹",                inline=False            )                        embed.add_field(                name="â±ï¸ é¸å–®æœ‰æ•ˆæ™‚é–“",                value="æ­¤é¸å–®å°‡åœ¨2åˆ†é˜å¾Œè‡ªå‹•å¤±æ•ˆ",                inline=False            )                        embed.set_footer(text="è³‡æ–™ä¾†æº: ç¶“æ¿Ÿéƒ¨æ°´åˆ©ç½²")                        await interaction.response.send_message(embed=embed, view=view)                    except Exception as e:            logger.error(f"å‰µå»ºæ°´åº«æŸ¥è©¢é¸å–®æ™‚ç™¼ç”ŸéŒ¯èª¤: {str(e)}")            await interaction.response.send_message(                embed=discord.Embed(                    title="âŒ éŒ¯èª¤",                    description="ç„¡æ³•é¡¯ç¤ºæ°´åº«æŸ¥è©¢é¸å–®ï¼Œè«‹ç¨å¾Œå†è©¦",                    color=discord.Color.red()                ),                ephemeral=True            )    @app_commands.command(        name="water_info",        description="æŸ¥è©¢æ°´åº«å³æ™‚æ°´æƒ…è³‡æ–™"    )    async def water_info(self, interaction: discord.Interaction):        """é–‹å•Ÿä¸€å€‹ä¸‹æ‹‰å¼é¸å–®ä¾†é¸æ“‡è¦æŸ¥è©¢çš„æ°´åº«æ°´æƒ…è³‡æ–™"""        try:            # å‰µå»ºä¸‹æ‹‰å¼é¸å–®è¦–åœ–            view = WaterInfoSelectView(self)                        # ç™¼é€é¸æ“‡æç¤ºè¨Šæ¯            embed = discord.Embed(                title="ğŸ’§ æ°´åº«å³æ™‚æ°´æƒ…æŸ¥è©¢",                description="è«‹å¾ä¸‹æ–¹é¸å–®é¸æ“‡è¦æŸ¥è©¢çš„æ°´åº«",                color=discord.Color.blue()            )                        embed.add_field(                name="ğŸ“‹ æ°´æƒ…è³‡è¨ŠåŒ…å«",                value="â€¢ ç›®å‰æ°´ä½\nâ€¢ æœ‰æ•ˆå®¹é‡\nâ€¢ æœ‰æ•ˆè“„æ°´é‡\nâ€¢ è“„æ°´ç™¾åˆ†æ¯”\nâ€¢ é€²å‡ºæ°´é‡\nâ€¢ æ°´æƒ…ç‹€æ…‹",                inline=False            )                        embed.add_field(                name="â±ï¸ é¸å–®æœ‰æ•ˆæ™‚é–“",                value="æ­¤é¸å–®å°‡åœ¨2åˆ†é˜å¾Œè‡ªå‹•å¤±æ•ˆ",                inline=False            )                        embed.set_footer(text="è³‡æ–™ä¾†æº: ç¶“æ¿Ÿéƒ¨æ°´åˆ©ç½²")                        await interaction.response.send_message(embed=embed, view=view)                    except Exception as e:            logger.error(f"å‰µå»ºæ°´åº«æ°´æƒ…æŸ¥è©¢é¸å–®æ™‚ç™¼ç”ŸéŒ¯èª¤: {str(e)}")            await interaction.response.send_message(                embed=discord.Embed(                    title="âŒ éŒ¯èª¤",                    description="ç„¡æ³•é¡¯ç¤ºæ°´åº«æ°´æƒ…æŸ¥è©¢é¸å–®ï¼Œè«‹ç¨å¾Œå†è©¦",                    color=discord.Color.red()                ),                ephemeral=True            )    @app_commands.command(        name="town_weather",        description="æŸ¥è©¢é„‰é®å¤©æ°£é å ±"    )    async def town_weather(self, interaction: discord.Interaction):        """é¡¯ç¤ºé„‰é®å¤©æ°£é å ±é¸å–®"""        try:            # ä½¿ç”¨ä¸‹æ‹‰é¸å–®è®“ç”¨æˆ¶é¸æ“‡é„‰é®            view = TownWeatherSelectView(self)            await interaction.response.send_message(                "è«‹é¸æ“‡è¦æŸ¥è©¢çš„é„‰é®ï¼š",                view=view,                ephemeral=True            )            logger.info(f"ç”¨æˆ¶ {interaction.user} é–‹å•Ÿäº†é„‰é®å¤©æ°£é å ±é¸å–®")                    except Exception as e:            logger.error(f"é¡¯ç¤ºé„‰é®å¤©æ°£é å ±é¸å–®æ™‚ç™¼ç”ŸéŒ¯èª¤: {str(e)}")            await interaction.response.send_message(                embed=discord.Embed(                    title="âŒ éŒ¯èª¤",                    description="ç„¡æ³•è¼‰å…¥é„‰é®å¤©æ°£é å ±é¸å–®ï¼Œè«‹ç¨å¾Œå†è©¦",                    color=discord.Color.red()                ),                ephemeral=True            )async def setup(bot):    await bot.add_cog(InfoCommands(bot))@echo off
echo Pushing changes to GitHub...
git add .
git commit -m "Automated commit by bot startup"
git push origin main
echo Starting the bot...
python bot.py
pause

