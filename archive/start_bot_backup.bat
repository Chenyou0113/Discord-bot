@echo off
echo ===================================
echo Discord Bot 啟動腳本 (最新版本)
echo ===================================
echo.
echo 此腳本將啟動 Discord 機器人
echo 功能: 支持2025年地震資料新格式及其他優化
echo.
echo 按任意鍵開始啟動機器人...
pause > nul

echo.
echo 檢查 Python 是否已安裝...
python --version > nul 2>&1
if %errorlevel% neq 0 (
    echo [錯誤] 找不到 Python。請確認 Python 已安裝且添加到系統路徑中。
    goto :error
)

echo [成功] Python 已安裝

echo 檢查是否存在必要的檔案...
if not exist "bot.py" (
    echo [錯誤] 找不到 bot.py 檔案。請確認您在正確的目錄中執行此腳本。
    goto :error
)

if not exist "cogs\info_commands_fixed_v4.py" (
    echo [錯誤] 找不到 cogs\info_commands_fixed_v4.py 檔案。
    goto :error
)

echo [成功] 找到所有必要檔案

echo 檢查是否已安裝必要的套件...
python -c "import discord, asyncio, aiohttp, google.generativeai, dotenv" > nul 2>&1
if %errorlevel% neq 0 (
    echo [警告] 可能缺少一些必要的套件。嘗試安裝...
    echo 安裝必要的套件...
    pip install -r requirements.txt
    if %errorlevel% neq 0 (
        echo [錯誤] 安裝套件時發生錯誤。
        goto :error
    )
)

echo [成功] 所有必要套件已安裝

echo 正在設置網路環境...
set PYTHONHTTPSVERIFY=0
set AIOHTTP_NO_EXTENSIONS=1
set SSL_CERT_FILE=
set REQUESTS_CA_BUNDLE=
set CURL_CA_BUNDLE=

echo.
echo 正在啟動 Discord 機器人...
echo 請等待約 1-2 分鐘，讓斜線指令完成同步...
echo.
echo 啟動日誌:
echo ------------------------------

python -X dev bot.py
if errorlevel 1 (    echo 錯誤：機器人啟動失敗
    goto :error
)

:error
echo.
echo [錯誤] 啟動機器人時發生錯誤。
echo 請檢查上方的錯誤訊息，或查看 bot.log 檔案以獲取更詳細的錯誤資訊。
pause
exit /b 1

:end
echo.
echo 機器人已停止運行。
pause
exit /b 0
class WeatherSelectView(View):
    def __init__(self, cog):
        super().__init__(timeout=120)  # 設定選單超時時間為120秒
        self.cog = cog
        self.add_item(self.create_select_menu())
echo.
    def create_select_menu(self):
        select = Select(            placeholder="請選擇縣市...",            min_values=1,            max_values=1        )                # 依照區域分組添加選項        for region, cities in TW_REGIONS.items():            for city in cities:                select.add_option(                    label=city,                    value=city,                    description=f"{region}地區",                    emoji="🌆" if city.endswith("市") else "🏞️"                )                select.callback = self.select_callback        return select    async def select_callback(self, interaction: discord.Interaction):        """處理縣市選擇後的回調函數"""        selected_city = interaction.data["values"][0]                try:            await interaction.response.defer(ephemeral=False, thinking=True)                        # 獲取天氣資料            try:                async with asyncio.timeout(5):  # 設定5秒超時                    data = await self.cog.fetch_weather_data()            except asyncio.TimeoutError:                # 如果超時，檢查快取                data = self.cog.weather_cache                                if not data:                    await interaction.followup.send(                        embed=discord.Embed(                            title="⚠️ 處理超時",                            description="獲取天氣資料時發生延遲，請稍後再試",                            color=discord.Color.orange()                        )                    )                    return                        if not data:                await interaction.followup.send(                    embed=discord.Embed(                        title="❌ 錯誤",                        description="無法獲取天氣資料，請稍後再試",                        color=discord.Color.red()                    )                )                return                        # 格式化並發送天氣資料            embed = self.cog.format_weather_data(data, selected_city)            await interaction.followup.send(embed=embed)            logger.info(f"用戶 {interaction.user} 查詢了 {selected_city} 的天氣預報")                    except Exception as e:            logger.error(f"處理天氣查詢選擇時發生錯誤: {str(e)}")            await interaction.followup.send(                embed=discord.Embed(                    title="❌ 錯誤",                    description="處理選擇時發生錯誤，請稍後再試",                    color=discord.Color.red()                )            )                async def on_timeout(self):        """處理選單逾時"""        # 選單逾時時，禁用所有選項        for item in self.children:            item.disabled = Trueclass ReservoirSelectView(View):    def __init__(self, cog):        super().__init__(timeout=120)  # 設定選單超時時間為120秒        self.cog = cog        self.add_item(self.create_select_menu())    def create_select_menu(self):        """創建水庫選擇選單"""        select = Select(            placeholder="選擇要查詢的水庫",            min_values=1,            max_values=1        )        reservoirs_by_region = {            "北部": ["石門水庫", "寶山第二水庫", "永和山水庫", "寶山水庫", "德基水庫"],            "中部": ["鯉魚潭水庫", "德基水庫", "霧社水庫", "日月潭水庫", "仁義潭水庫"],            "南部": ["曾文水庫", "烏山頭水庫", "南化水庫", "阿公店水庫", "牡丹水庫"]        }                try:            # 計算總選項數量，確保不超過25個            total_options = sum(len(reservoirs) for reservoirs in reservoirs_by_region.values())            logger.info(f"水庫選單選項數量: {total_options}")                        if total_options > 25:                logger.warning("水庫選項超過25個，將進行裁剪")                            # 添加水庫選項            option_count = 0            for region, reservoirs in reservoirs_by_region.items():                for reservoir in reservoirs:                    if option_count < 25:  # 確保不超過25個選項                        select.add_option(                            label=reservoir,                            value=reservoir,                            description=f"{region}地區",                            emoji="💧"                        )                        option_count += 1                    else:                        logger.warning(f"已達選項上限，略過水庫: {reservoir}")        except Exception as e:            logger.error(f"建立水庫選單時發生錯誤: {str(e)}")            # 發生錯誤時添加一個預設選項            select.add_option(                label="錯誤",                value="error",                description="無法載入水庫選項",                emoji="⚠️"            )                select.callback = self.select_callback        return select    async def select_callback(self, interaction: discord.Interaction):        """處理水庫選擇後的回調函數"""        selected_reservoir = interaction.data["values"][0]                try:            await interaction.response.defer(ephemeral=False, thinking=True)                        # 獲取水庫資料            try:                async with asyncio.timeout(5):  # 設定5秒超時                    data = await self.cog.fetch_reservoir_data()            except asyncio.TimeoutError:                # 如果超時，檢查快取                data = self.cog.reservoir_cache                                if not data:                    await interaction.followup.send(                        embed=discord.Embed(                            title="⚠️ 處理超時",                            description="獲取水庫資料時發生延遲，請稍後再試",                            color=discord.Color.orange()                        )                    )                    return                        if not data:                await interaction.followup.send(                    embed=discord.Embed(                        title="❌ 錯誤",                        description="無法獲取水庫資料，請稍後再試",                        color=discord.Color.red()                    )                )                return                        # 格式化並發送水庫資料            embed = self.cog.format_reservoir_data(data, selected_reservoir)            await interaction.followup.send(embed=embed)            logger.info(f"用戶 {interaction.user} 查詢了 {selected_reservoir} 的水庫情況")                    except Exception as e:            logger.error(f"處理水庫查詢選擇時發生錯誤: {str(e)}")            await interaction.followup.send(                embed=discord.Embed(                    title="❌ 錯誤",                    description="處理選擇時發生錯誤，請稍後再試",                    color=discord.Color.red()                )            )                async def on_timeout(self):        """處理選單逾時"""        # 選單逾時時，禁用所有選項        for item in self.children:            item.disabled = Trueclass WaterInfoSelectView(View):    def __init__(self, cog):        super().__init__(timeout=120)  # 設定選單超時時間為120秒        self.cog = cog        self.add_item(self.create_select_menu())    def create_select_menu(self):        """創建水庫選擇選單"""        select = Select(            placeholder="選擇要查詢的水庫",            min_values=1,            max_values=1        )        reservoirs_by_region = {            "北部": ["石門水庫", "寶山第二水庫", "永和山水庫", "寶山水庫", "德基水庫"],            "中部": ["鯉魚潭水庫", "德基水庫", "霧社水庫", "日月潭水庫", "仁義潭水庫"],            "南部": ["曾文水庫", "烏山頭水庫", "南化水庫", "阿公店水庫", "牡丹水庫"]        }                try:            # 計算總選項數量，確保不超過25個            total_options = sum(len(reservoirs) for reservoirs in reservoirs_by_region.values())            logger.info(f"水庫選單選項數量: {total_options}")                        if total_options > 25:                logger.warning("水庫選項超過25個，將進行裁剪")                            # 添加水庫選項            option_count = 0            for region, reservoirs in reservoirs_by_region.items():                for reservoir in reservoirs:                    if option_count < 25:  # 確保不超過25個選項                        select.add_option(                            label=reservoir,                            value=reservoir,                            description=f"{region}地區",                            emoji="💧"                        )                        option_count += 1                    else:                        logger.warning(f"已達選項上限，略過水庫: {reservoir}")        except Exception as e:            logger.error(f"建立水庫選單時發生錯誤: {str(e)}")            # 發生錯誤時添加一個預設選項            select.add_option(                label="錯誤",                value="error",                description="無法載入水庫選項",                emoji="⚠️"            )                select.callback = self.select_callback        return select    async def select_callback(self, interaction: discord.Interaction):        """處理水庫選擇後的回調函數"""        selected_reservoir = interaction.data["values"][0]                try:            await interaction.response.defer(ephemeral=False, thinking=True)                        # 獲取水庫資料            try:                async with asyncio.timeout(5):  # 設定5秒超時                    data = await self.cog.fetch_water_info_data()            except asyncio.TimeoutError:                # 如果超時，檢查快取                data = self.cog.water_info_cache                                if not data:                    await interaction.followup.send(                        embed=discord.Embed(                            title="⚠️ 處理超時",                            description="獲取水情資料時發生延遲，請稍後再試",                            color=discord.Color.orange()                        )                    )                    return                        if not data:                await interaction.followup.send(                    embed=discord.Embed(                        title="❌ 錯誤",                        description="無法獲取水情資料，請稍後再試",                        color=discord.Color.red()                    )                )                return                        # 格式化並發送水庫資料            embed = self.cog.format_water_info_data(data, selected_reservoir)            await interaction.followup.send(embed=embed)            logger.info(f"用戶 {interaction.user} 查詢了 {selected_reservoir} 的水情")                    except Exception as e:            logger.error(f"處理水情查詢選擇時發生錯誤: {str(e)}")            await interaction.followup.send(                embed=discord.Embed(                    title="❌ 錯誤",                    description="處理選擇時發生錯誤，請稍後再試",                    color=discord.Color.red()                )            )                async def on_timeout(self):        """處理選單逾時"""        # 選單逾時時，禁用所有選項        for item in self.children:            item.disabled = Trueclass TownWeatherSelectView(View):    def __init__(self, cog):        super().__init__(timeout=120)  # 設定選單超時時間為120秒        self.cog = cog        self.add_item(self.create_select_menu())    def create_select_menu(self):        select = Select(            placeholder="請選擇鄉鎮...",            min_values=1,            max_values=1        )                # 台北市鄉鎮列表        taipei_towns = [            "松山區", "信義區", "大安區", "中山區", "中正區", "大同區",            "萬華區", "文山區", "南港區", "內湖區", "士林區", "北投區"        ]                # 新北市鄉鎮列表（部分）        new_taipei_towns = [            "板橋區", "三重區", "中和區", "永和區", "新莊區", "新店區",            "樹林區", "鶯歌區", "三峽區", "淡水區", "汐止區", "瑞芳區"        ]                # 依照區域分組添加選項        for town in taipei_towns:            select.add_option(                label=town,                value=town,                description="台北市",                emoji="🏙️"            )                for town in new_taipei_towns:            select.add_option(                label=town,                value=town,                description="新北市",                emoji="🌆"            )                select.callback = self.select_callback        return select    async def select_callback(self, interaction: discord.Interaction):        """處理鄉鎮選擇後的回調函數"""        selected_town = interaction.data["values"][0]                try:            await interaction.response.defer(ephemeral=False, thinking=True)                        # 獲取天氣資料            try:                async with asyncio.timeout(5):  # 設定5秒超時                    data = await self.cog.fetch_town_weather_data()            except asyncio.TimeoutError:                # 如果超時，檢查快取                data = self.cog.town_weather_cache                                if not data:                    await interaction.followup.send(                        embed=discord.Embed(                            title="⚠️ 處理超時",                            description="獲取天氣資料時發生延遲，請稍後再試",                            color=discord.Color.orange()                        )                    )                    return                        if not data:                await interaction.followup.send(                    embed=discord.Embed(                        title="❌ 錯誤",                        description="無法獲取天氣資料，請稍後再試",                        color=discord.Color.red()                    )                )                return                        # 格式化並發送天氣資料            embed = self.cog.format_town_weather_data(data, selected_town)            await interaction.followup.send(embed=embed)            logger.info(f"用戶 {interaction.user} 查詢了 {selected_town} 的天氣預報")                    except Exception as e:            logger.error(f"處理天氣查詢選擇時發生錯誤: {str(e)}")            await interaction.followup.send(                embed=discord.Embed(                    title="❌ 錯誤",                    description="處理選擇時發生錯誤，請稍後再試",                    color=discord.Color.red()                )            )                async def on_timeout(self):        """處理選單逾時"""        # 選單逾時時，禁用所有選項        for item in self.children:            item.disabled = True# 新增水庫水情資料分頁器類別class WaterInfoPaginator(discord.ui.View):    """用於分頁顯示所有水庫水情資料的分頁器"""        def __init__(self, embeds: list, timeout: int = 180):        super().__init__(timeout=timeout)        self.embeds = embeds        self.current_page = 0        self.total_pages = len(embeds)                # 更新按鈕狀態        self._update_buttons()        def _update_buttons(self):        """更新按鈕狀態"""        # 第一頁時，禁用上一頁和第一頁按鈕        self.first_page.disabled = (self.current_page == 0)        self.prev_page.disabled = (self.current_page == 0)                # 最後一頁時，禁用下一頁和最後一頁按鈕        self.next_page.disabled = (self.current_page == self.total_pages - 1)        self.last_page.disabled = (self.current_page == self.total_pages - 1)        async def update_message(self, interaction: discord.Interaction):        """更新訊息以顯示當前頁面"""        embed = self.embeds[self.current_page]        # 添加頁碼資訊到嵌入訊息        embed.set_footer(text=f"第 {self.current_page + 1}/{self.total_pages} 頁 | 資料來源: 經濟部水利署")        self._update_buttons()        await interaction.response.edit_message(embed=embed, view=self)        @discord.ui.button(label="首頁", style=discord.ButtonStyle.gray, emoji="⏮️")    async def first_page(self, interaction: discord.Interaction, button: discord.ui.Button):        """跳轉到第一頁"""        self.current_page = 0        await self.update_message(interaction)        @discord.ui.button(label="上一頁", style=discord.ButtonStyle.blurple, emoji="◀️")    async def prev_page(self, interaction: discord.Interaction, button: discord.ui.Button):        """顯示上一頁"""        self.current_page -= 1        if self.current_page < 0:            self.current_page = 0        await self.update_message(interaction)        @discord.ui.button(label="下一頁", style=discord.ButtonStyle.blurple, emoji="▶️")    async def next_page(self, interaction: discord.Interaction, button: discord.ui.Button):        """顯示下一頁"""        self.current_page += 1        if self.current_page >= self.total_pages:            self.current_page = self.total_pages - 1        await self.update_message(interaction)        @discord.ui.button(label="尾頁", style=discord.ButtonStyle.gray, emoji="⏭️")    async def last_page(self, interaction: discord.Interaction, button: discord.ui.Button):        """跳轉到最後一頁"""        self.current_page = self.total_pages - 1        await self.update_message(interaction)        async def on_timeout(self):        """處理分頁器逾時"""        # 分頁器逾時時，禁用所有按鈕        for item in self.children:            item.disabled = Trueclass InfoCommands(commands.Cog):    def __init__(self, bot: commands.Bot):        self.bot = bot        self.earthquake_cache = {}        self.weather_cache = {}        self.weather_alert_cache = {}        self.reservoir_cache = {}        self.water_info_cache = {}  # 新增水情資料快取        self.town_weather_cache = {}  # 新增鄉鎮天氣快取        self.cache_time = 0        self.weather_cache_time = 0        self.weather_alert_cache_time = 0        self.reservoir_cache_time = 0        self.water_info_cache_time = 0  # 新增水情資料快取時間        self.town_weather_cache_time = 0  # 新增鄉鎮天氣快取時間        self.api_auth = "CWA-675CED45-09DF-4249-9599-B9B5A5AB761A"        self.notification_channels = {}        self.last_eq_time = {}        self.check_interval = 300  # 每5分鐘檢查一次                # 建立 aiohttp 工作階段        self.session = None        self.bot.loop.create_task(self.init_aiohttp_session())                # 開始地震監控        self.eq_check_task = self.bot.loop.create_task(self.check_earthquake_updates())    async def init_aiohttp_session(self):        """初始化 aiohttp 工作階段"""        # 建立支援 SSL 的連接器        connector = aiohttp.TCPConnector(            ssl=True,           # 啟用 SSL 驗證            verify_ssl=True,    # 驗證 SSL 證書            limit=10           # 同時連接數限制        )                # 建立 aiohttp 工作階段        self.session = aiohttp.ClientSession(            timeout=aiohttp.ClientTimeout(total=20, connect=10, sock_read=15),            connector=connector        )        logger.info("已初始化 aiohttp 工作階段 (SSL驗證已啟用)")    async def cog_unload(self):        """當Cog被卸載時停止地震檢查任務和關閉aiohttp工作階段"""        self.eq_check_task.cancel()        if self.session and not self.session.closed:            await self.session.close()            logger.info("已關閉 aiohttp 工作階段")    async def check_earthquake_updates(self):        """定期檢查是否有新地震"""        await self.bot.wait_until_ready()        while not self.bot.is_closed():            try:                # 檢查一般地震                data = await self.fetch_earthquake_data(small_area=False)                if data and 'records' in data and 'earthquake' in data['records']:                    latest_eq = data['records']['earthquake'][0]                    report_time = latest_eq['reportTime']                                        # 檢查是否為新地震                    for guild_id, channel_id in self.notification_channels.items():                        if guild_id not in self.last_eq_time or report_time != self.last_eq_time[guild_id]:                            # 更新最後地震時間                            self.last_eq_time[guild_id] = report_time                                                        # 發送通知                            try:                                channel = self.bot.get_channel(channel_id)                                if channel:                                    embed = self.format_earthquake_data(data, small_area=False)                                    embed.title = "🚨 新地震通報！"                                    await channel.send(embed=embed)                            except Exception as e:                                logger.error(f"發送地震通知時發生錯誤: {str(e)}")                            except asyncio.CancelledError:                # 正常取消                break            except Exception as e:                logger.error(f"檢查地震更新時發生錯誤: {str(e)}")                        await asyncio.sleep(self.check_interval)    async def fetch_with_retry(self, url: str, timeout: int = 20, max_retries: int = 3) -> Optional[Dict[str, Any]]:        """以重試機制發送非同步請求"""        for attempt in range(max_retries):            try:                if self.session is None or self.session.closed:                    # 建立新的會話時禁用SSL驗證                    connector = aiohttp.TCPConnector(ssl=False)                    self.session = aiohttp.ClientSession(                        timeout=aiohttp.ClientTimeout(total=timeout),                        connector=connector                    )                async with self.session.get(url, timeout=timeout) as response:                    if response.status == 200:                        return await response.json()                    else:                        logger.warning(f"API請求返回非200狀態碼: {response.status}")                        return None            except asyncio.TimeoutError:                logger.error(f"API請求超時 (嘗試 {attempt+1}/{max_retries})")                if attempt < max_retries - 1:                    await asyncio.sleep(1 * (attempt + 1))            except Exception as e:                logger.error(f"API請求錯誤 (嘗試 {attempt+1}/{max_retries}): {str(e)}")                if attempt < max_retries - 1:                    await asyncio.sleep(1 * (attempt + 1))                if attempt == max_retries - 1:                    # 最後一次嘗試失敗時，記錄詳細錯誤                    logger.error(f"最終API請求失敗: {str(e)}")        return None    async def fetch_earthquake_data(self, small_area: bool = False) -> Optional[Dict[str, Any]]:        """從氣象局取得最新地震資料 (使用非同步請求)"""        current_time = datetime.datetime.now().timestamp()        cache_key = "small" if small_area else "normal"                # 如果快取資料未過期（5分鐘內），直接返回快取        if (cache_key in self.earthquake_cache and             current_time - self.cache_time < 300):            logger.info(f"使用快取的地震資料 (類型: {cache_key})")            return self.earthquake_cache[cache_key]        try:            # 選擇適當的 API 端點            if small_area:                url = f"https://opendata.cwa.gov.tw/api/v1/rest/datastore/E-A0016-001?Authorization={self.api_auth}"            else:                url = f"https://opendata.cwa.gov.tw/api/v1/rest/datastore/E-A0015-001?Authorization={self.api_auth}"                        # 使用非同步請求獲取資料            data = await self.fetch_with_retry(url, timeout=15, max_retries=3)                        if data:                # 更新快取                self.earthquake_cache[cache_key] = data                self.cache_time = current_time                logger.info(f"成功獲取並更新地震資料快取")                return data            else:                # 如果請求失敗，檢查是否有快取資料可用                if cache_key in self.earthquake_cache:                    logger.warning("地震資料請求失敗，使用過期的快取資料")                    return self.earthquake_cache[cache_key]                return None                    except Exception as e:            logger.error(f"獲取地震資料時發生錯誤: {str(e)}")                        # 如果發生錯誤，檢查是否有快取資料可用            if cache_key in self.earthquake_cache:                logger.info("發生錯誤，使用地震快取資料")                return self.earthquake_cache[cache_key]                        return None    async def fetch_weather_data(self) -> Optional[Dict[str, Any]]:        """從氣象局取得36小時天氣預報資料 (使用非同步請求)"""        current_time = datetime.datetime.now().timestamp()                # 如果快取資料未過期（30分鐘內），直接返回快取        if (self.weather_cache and             current_time - self.weather_cache_time < 1800):            logger.info("使用快取的天氣預報資料")            return self.weather_cache        try:            url = f"https://opendata.cwa.gov.tw/api/v1/rest/datastore/F-C0032-001?Authorization={self.api_auth}"                        # 使用非同步請求獲取資料            data = await self.fetch_with_retry(url, timeout=15, max_retries=3)                        if data:                # 更新快取                self.weather_cache = data                self.weather_cache_time = current_time                logger.info("成功獲取並更新天氣預報資料快取")                return data            else:                # 如果請求失敗，檢查是否有快取資料可用                if self.weather_cache:                    logger.warning("天氣資料請求失敗，使用過期的快取資料")                    return self.weather_cache                return None                        except Exception as e:            logger.error(f"獲取天氣預報資料時發生錯誤: {str(e)}")                        # 如果發生錯誤，檢查是否有快取資料可用            if self.weather_cache:                logger.info("發生錯誤，使用天氣預報快取資料")                return self.weather_cache                            return None    async def fetch_reservoir_data(self) -> Optional[Dict[str, Any]]:        """從水利署取得最新水庫資料 (使用非同步請求)"""        current_time = datetime.datetime.now().timestamp()                # 如果快取資料未過期（30分鐘內），直接返回快取        if (self.reservoir_cache and             current_time - self.reservoir_cache_time < 1800):            logger.info("使用快取的水庫資料")            return self.reservoir_cache        try:            url = "https://data.wra.gov.tw/OpenAPI/api/OpenData/50C8256D-30C5-4B8D-9B84-2E14D5C6DF71/Data?size=1000&page=1"                        # 使用非同步請求獲取資料            data = await self.fetch_with_retry(url, timeout=20, max_retries=3)                        if data:                # 更新快取                self.reservoir_cache = data                self.reservoir_cache_time = current_time                logger.info("成功獲取並更新水庫資料快取")                return data            else:                # 如果請求失敗，檢查是否有快取資料可用                if self.reservoir_cache:                    logger.warning("水庫資料請求失敗，使用過期的快取資料")                    return self.reservoir_cache                return None                        except Exception as e:            logger.error(f"獲取水庫資料時發生錯誤: {str(e)}")                        # 如果發生錯誤，檢查是否有快取資料可用            if self.reservoir_cache:                logger.info("發生錯誤，使用水庫資料快取")                return self.reservoir_cache                            return None    async def fetch_water_info_data(self) -> Optional[Dict[str, Any]]:        """從水利署取得最新水庫水情資料 (使用非同步請求)"""        current_time = datetime.datetime.now().timestamp()                # 如果快取資料未過期（30分鐘內），直接返回快取        if (self.water_info_cache and             current_time - self.water_info_cache_time < 1800):            logger.info("使用快取的水庫水情資料")            return self.water_info_cache        try:            # 設定API端點            url = "https://data.wra.gov.tw/OpenAPI/api/OpenData/1602CA19-B224-4CC3-AA31-11B1B124530F/Data?size=1000&page=1"                        # 使用增強版的非同步請求方法，增加超時時間和重試次數            data = None                        # 首次嘗試使用標準超時設定            try:                async with asyncio.timeout(30):  # 增加總超時時間到30秒                    data = await self.fetch_with_retry(url, timeout=25, max_retries=5)            except asyncio.TimeoutError:                logger.warning("第一次獲取水庫水情資料超時，將嘗試降級請求")                # 如果第一次超時，嘗試使用更寬鬆的超時設定                try:                    # 創建新的會話並設定更寬鬆的超時                    async with aiohttp.ClientSession(                        timeout=aiohttp.ClientTimeout(total=40, connect=20, sock_read=30),                        connector=aiohttp.TCPConnector(verify_ssl=False)                    ) as session:                        async with session.get(url) as response:                            if response.status == 200:                                data = await response.json()                                logger.info("透過降級請求成功獲取水庫水情資料")                            else:                                logger.error(f"降級請求失敗: HTTP狀態碼 {response.status}")                except Exception as e:                    logger.error(f"降級請求時發生錯誤: {str(e)}")                        if data:                # 驗證數據結構                if 'responseData' in data and isinstance(data['responseData'], list):                    # 增強數據驗證: 檢查第一個項目是否包含必要字段                    if data['responseData'] and isinstance(data['responseData'][0], dict) and 'ReservoirName' in data['responseData'][0]:                        # 更新快取                        self.water_info_cache = data                        self.water_info_cache_time = current_time                        logger.info("成功獲取並更新水庫水情資料快取")                        return data                    else:                        logger.error("水庫水情資料結構無效: 資料項目缺少必要字段")                else:                    logger.error(f"水庫水情數據格式異常: {list(data.keys()) if isinstance(data, dict) else '非字典類型'}")                                # 即使數據結構不完整，也返回獲取到的數據，避免完全失敗                logger.warning("水庫水情數據結構異常，但仍返回獲取到的數據")                return data            else:                # 如果請求失敗，檢查是否有快取資料可用                if self.water_info_cache:                    logger.warning("水庫水情請求失敗，使用過期的快取資料")                    return self.water_info_cache                else:                    logger.error("無法獲取水庫水情資料，且沒有可用的快取")                return None                        except asyncio.TimeoutError:            logger.error("獲取水庫水情資料超時")            # 直接使用快取，避免再次嘗試可能會超時的請求            if self.water_info_cache:                logger.info("發生超時，使用水庫水情快取資料")                return self.water_info_cache            return None                        except Exception as e:            logger.error(f"獲取水庫水情資料時發生錯誤: {str(e)}")                        # 如果發生錯誤，檢查是否有快取資料可用            if self.water_info_cache:                logger.info("發生錯誤，使用水庫水情快取資料")                return self.water_info_cache                            return None    async def fetch_town_weather_data(self) -> Optional[Dict[str, Any]]:        """從氣象局取得鄉鎮天氣預報資料"""        current_time = datetime.datetime.now().timestamp()                # 如果快取資料未過期（30分鐘內），直接返回快取        if (self.town_weather_cache and             current_time - self.town_weather_cache_time < 1800):            logger.info("使用快取的鄉鎮天氣預報資料")            return self.town_weather_cache        try:            url = f"https://opendata.cwa.gov.tw/api/v1/rest/datastore/F-D0047-093?Authorization={self.api_auth}&locationId=F-D0047-001"                        # 使用非同步請求獲取資料            data = await self.fetch_with_retry(url, timeout=20, max_retries=3)                        if data:                # 更新快取                self.town_weather_cache = data                self.town_weather_cache_time = current_time                logger.info("成功獲取並更新鄉鎮天氣預報資料快取")                return data            else:                # 如果請求失敗，檢查是否有快取資料可用                if self.town_weather_cache:                    logger.warning("鄉鎮天氣資料請求失敗，使用過期的快取資料")                    return self.town_weather_cache                return None                        except Exception as e:            logger.error(f"獲取鄉鎮天氣預報資料時發生錯誤: {str(e)}")                        # 如果發生錯誤，檢查是否有快取資料可用            if self.town_weather_cache:                logger.info("發生錯誤，使用鄉鎮天氣預報快取資料")                return self.town_weather_cache                            return None    def format_reservoir_data(self, data: Dict[str, Any], reservoir_name: str) -> discord.Embed:        """格式化水庫資料為 Discord 嵌入消息"""        try:            # 檢查資料結構，適應可能的API變化            reservoirs = None                        # 檢查舊格式 (有data欄位)            if 'data' in data:                reservoirs = data['data']            # 檢查可能的新格式            elif 'ReservoirConditionsToday' in data:                reservoirs = data['ReservoirConditionsToday']            elif 'ReservoirInfo' in data:                reservoirs = data['ReservoirInfo']            elif isinstance(data, list):  # 可能直接是列表格式                reservoirs = data            else:                # 嘗試找出資料中可能包含水庫資訊的欄位                for key, value in data.items():                    if isinstance(value, list) and len(value) > 0:                        # 檢查第一個元素是否像水庫資料 (有 ReservoirName 欄位)                        if isinstance(value[0], dict) and 'ReservoirName' in value[0]:                            reservoirs = value                            logger.info(f"找到可能的水庫資料欄位: {key}")                            break                        if not reservoirs:                logger.error(f"無法辨識水庫資料格式. 資料結構: {data.keys() if isinstance(data, dict) else type(data)}")                return discord.Embed(                    title="⚠️ 資料格式錯誤",                    description="目前無法解析水庫資料格式，請通知管理員檢查API變更",                    color=discord.Color.orange()                )                        if not reservoirs:                return discord.Embed(                    title="⚠️ 沒有水庫資料",                    description="目前沒有任何水庫資料可供顯示",                    color=discord.Color.orange()                )                        # 尋找指定水庫的資料            reservoir_data = None            for reservoir in reservoirs:                if reservoir.get('ReservoirName') == reservoir_name:                    reservoir_data = reservoir                    break                        if not reservoir_data:                return discord.Embed(                    title="❌ 找不到資料",                    description=f"找不到 {reservoir_name} 的資料",                    color=discord.Color.red()                )                        # 解析水庫資料            name = reservoir_data.get('ReservoirName', '無資料')            time = reservoir_data.get('ObservationTime', reservoir_data.get('DataTime', '無資料'))            capacity = reservoir_data.get('EffectiveCapacity', reservoir_data.get('Capacity', '無資料'))  # 有效容量            current_volume = reservoir_data.get('EffectiveWaterStorageCapacity', reservoir_data.get('WaterStorage', '無資料'))  # 有效蓄水量            percentage = reservoir_data.get('PercentageOfStorage', reservoir_data.get('CapacityPercentage', '無資料'))  # 蓄水百分比            inflow = reservoir_data.get('InflowVolume', reservoir_data.get('Inflow', '無資料'))  # 進水量            outflow = reservoir_data.get('OutflowTotal', reservoir_data.get('Outflow', '無資料'))  # 出水量                        # 處理百分比格式，確保顯示為數字            if percentage and percentage != '無資料':                try:                    # 嘗試將百分比轉換為浮點數                    percentage = float(percentage)                    # 檢查是否已經是小數形式 (例如0.75代表75%)                    if percentage < 1.0:                        percentage = percentage * 100                    # 格式化為最多2位小數                    percentage = f"{percentage:.2f}".rstrip('0').rstrip('.') if '.' in f"{percentage:.2f}" else f"{percentage:.0f}"                except ValueError:                    # 如果無法轉換，保持原樣                    pass                        # 計算水情狀態            water_status = "正常"            status_color = discord.Color.green()            status_emoji = "✅"                        if percentage and percentage != '無資料':                try:                    percent_float = float(percentage)                    if percent_float < 20:                        water_status = "嚴重水情"                        status_color = discord.Color.red()                        status_emoji = "⚠️"                    elif percent_float < 30:                        water_status = "水情警戒"                        status_color = discord.Color.orange()                        status_emoji = "⚠️"                    elif percent_float < 50:                        water_status = "水情提醒"                        status_color = discord.Color.gold()                        status_emoji = "⚠️"                    elif percent_float < 70:                        water_status = "水情注意"                        status_color = discord.Color.blue()                        status_emoji = "ℹ️"                    elif percent_float >= 90:                        water_status = "水情充裕"                        status_color = discord.Color.dark_green()                        status_emoji = "💯"                except ValueError:                    # 如果無法轉換百分比，使用預設值                    pass                        # 建立嵌入消息            embed = discord.Embed(                title=f"💧 {name} 水庫每日營運情況",                description=f"觀測時間: {time}",                color=status_color            )                        embed.add_field(                name="📊 蓄水量",                value=f"目前蓄水量: {current_volume} 萬立方公尺\n"                      f"有效容量: {capacity} 萬立方公尺\n"                      f"蓄水百分比: {percentage}%",                inline=False            )                        embed.add_field(                name="🌊 進出水量",                value=f"進水量: {inflow} 立方公尺/秒\n"                      f"出水量: {outflow} 立方公尺/秒",                inline=False            )                        embed.add_field(                name=f"{status_emoji} 水情狀態",                value=water_status,                inline=False            )                        # 添加資料來源            embed.set_footer(text=f"資料來源: 經濟部水利署")                        return embed                    except ValueError as ve:            logger.error(f"格式化水庫資料時發生錯誤: {str(ve)}")            return discord.Embed(                title="❌ 資料格式錯誤",                description=f"無法解析水庫資料: {str(ve)}",                color=discord.Color.red()            )                    except Exception as e:            logger.error(f"格式化水庫資料時發生錯誤: {str(e)}")            return discord.Embed(                title="❌ 錯誤",                description="格式化水庫資料時發生錯誤，請稍後再試",                color=discord.Color.red()            )    def format_water_info_data(self, data: Dict[str, Any], reservoir_name: str) -> discord.Embed:        """格式化水庫水情資料為 Discord 嵌入消息"""        try:            # 檢查資料結構            if not data or 'responseData' not in data:                logger.error(f"無效的水庫水情資料格式: 缺少 responseData 欄位")                return discord.Embed(                    title="⚠️ 資料格式錯誤",                    description="無法讀取水庫水情資料，請通知管理員檢查API變更",                    color=discord.Color.orange()                )                        reservoirs = data.get('responseData', [])                        if not reservoirs:                return discord.Embed(                    title="⚠️ 沒有水庫水情資料",                    description="目前沒有任何水庫水情資料可供顯示",                    color=discord.Color.orange()                )                        # 尋找指定水庫的資料            reservoir_data = None            for reservoir in reservoirs:                if reservoir.get('ReservoirName') == reservoir_name:                    reservoir_data = reservoir                    break                        if not reservoir_data:                return discord.Embed(                    title="❌ 找不到資料",                    description=f"找不到 {reservoir_name} 的水情資料",                    color=discord.Color.red()                )                        # 解析水庫水情資料            name = reservoir_data.get('ReservoirName', '無資料')            time = reservoir_data.get('ObservationTime', '無資料')            water_level = reservoir_data.get('WaterLevel', '無資料')  # 水位高度            effective_capacity = reservoir_data.get('EffectiveCapacity', '無資料')  # 有效容量            effective_storage = reservoir_data.get('EffectiveStorage', '無資料')  # 有效蓄水量            percentage = reservoir_data.get('PercentageOfStorage', '無資料')  # 蓄水百分比            inflow = reservoir_data.get('InFlow', '無資料')  # 進水量            outflow = reservoir_data.get('OutFlow', '無資料')  # 出水量                        # 處理百分比格式，確保顯示為數字            if percentage and percentage != '無資料':                try:                    # 嘗試將百分比轉換為浮點數                    percentage = float(percentage)                    # 檢查是否已經是小數形式 (例如0.75代表75%)                    if percentage < 1.0:                        percentage = percentage * 100                    # 格式化為最多2位小數                    percentage = f"{percentage:.2f}".rstrip('0').rstrip('.') if '.' in f"{percentage:.2f}" else f"{percentage:.0f}"                except ValueError:                    # 如果無法轉換，保持原樣                    pass                        # 計算水情狀態            water_status = "正常"            status_color = discord.Color.green()            status_emoji = "✅"                        if percentage and percentage != '無資料':                try:                    percent_float = float(percentage)                    if percent_float < 20:                        water_status = "嚴重水情"                        status_color = discord.Color.red()                        status_emoji = "🔴"                    elif percent_float < 30:                        water_status = "水情警戒"                        status_color = discord.Color.orange()                        status_emoji = "🟠"                    elif percent_float < 50:                        water_status = "水情提醒"                        status_color = discord.Color.gold()                        status_emoji = "🟡"                    elif percent_float < 70:                        water_status = "水情注意"                        status_color = discord.Color.blue()                        status_emoji = "🔵"                    elif percent_float >= 90:                        water_status = "水情充裕"                        status_color = discord.Color.dark_green()                        status_emoji = "🟢"                except ValueError:                    # 如果無法轉換百分比，使用預設值                    pass                        # 建立嵌入消息            embed = discord.Embed(                title=f"💧 {name} 水庫水情資料",                description=f"觀測時間: {time}",                color=status_color            )                        embed.add_field(                name="📊 水庫水位",                value=f"目前水位: {water_level} 公尺",                inline=False            )                        embed.add_field(                name="🌊 蓄水情況",                value=f"有效容量: {effective_capacity} 萬立方公尺\n"                      f"有效蓄水量: {effective_storage} 萬立方公尺\n"                      f"蓄水百分比: {percentage}%",                inline=False            )                        embed.add_field(                name="🔄 進出水量",                value=f"進水量: {inflow} cms\n"                      f"出水量: {outflow} cms",                inline=False            )                        embed.add_field(                name=f"{status_emoji} 水情狀態",                value=water_status,                inline=False            )                        # 添加資料來源            embed.set_footer(text=f"資料來源: 經濟部水利署")                        return embed                    except Exception as e:            logger.error(f"格式化水庫水情資料時發生錯誤: {str(e)}")            return discord.Embed(                title="❌ 錯誤",                description="格式化水庫水情資料時發生錯誤，請稍後再試",                color=discord.Color.red()            )    def format_town_weather_data(self, data: Dict[str, Any], town_name: str) -> discord.Embed:        """格式化鄉鎮天氣預報資料為 Discord 嵌入消息"""        try:            # 檢查資料結構            if 'records' not in data or 'locations' not in data['records']:                return discord.Embed(                    title="❌ 資料格式錯誤",                    description="無法解析天氣資料",                    color=discord.Color.red()                )            # 尋找指定鄉鎮的資料            locations = data['records']['locations'][0]['location']            location_data = None            for loc in locations:                if loc['locationName'] == town_name:                    location_data = loc                    break            if not location_data:                return discord.Embed(                    title="❌ 找不到資料",                    description=f"找不到 {town_name} 的天氣資料",                    color=discord.Color.red()                )            # 整理天氣要素資料            weather_elements = location_data['weatherElement']            forecast_data = {}                        # 定義要素對應表            element_mapping = {                'Wx': '天氣現象',                'PoP12h': '降雨機率',                'T': '溫度',                'RH': '相對濕度',                'CI': '舒適度'            }            # 擷取未來24小時的預報資料            current_time = datetime.datetime.now()            forecast_times = []                        for element in weather_elements:                element_name = element['elementName']                if element_name in element_mapping:                    for time_slot in element['time'][:8]:  # 取前8個時段（約24小時）                        start_time = datetime.datetime.strptime(                            time_slot['startTime'],                            '%Y-%m-%d %H:%M:%S'                        )                        if start_time not in forecast_data:                            forecast_data[start_time] = {}                            forecast_times.append(start_time)                                                if element_name == 'Wx':                            forecast_data[start_time][element_mapping[element_name]] = time_slot['elementValue'][0]['value']                        elif element_name == 'PoP12h':                            # 降雨機率可能為空值                            value = time_slot['elementValue'][0]['value']                            forecast_data[start_time][element_mapping[element_name]] = f"{value}%" if value else "無資料"                        elif element_name == 'T':                            forecast_data[start_time][element_mapping[element_name]] = f"{time_slot['elementValue'][0]['value']}°C"                        elif element_name == 'RH':                            # 轉換為百分比                            rh_value = int(time_slot['elementValue'][0]['value'])                            forecast_data[start_time][element_mapping[element_name]] = f"{rh_value}%"                        else:                            forecast_data[start_time][element_mapping[element_name]] = time_slot['elementValue'][0]['value']            # 建立嵌入消息            embed = discord.Embed(                title=f"🌦️ {town_name} 天氣預報",                description=f"資料更新時間: {current_time.strftime('%Y/%m/%d %H:%M')}",                color=discord.Color.blue()            )            # 加入預報資料            for time in sorted(forecast_times)[:6]:  # 只顯示前6個時段                time_str = time.strftime('%m/%d %H:%M')                weather_info = forecast_data[time]                value = (                    f"天氣: {weather_info.get('天氣現象', '無資料')}\n"                    f"溫度: {weather_info.get('溫度', '無資料')}\n"                    f"濕度: {weather_info.get('相對濕度', '無資料')}\n"                    f"降雨機率: {weather_info.get('降雨機率', '無資料')}\n"                    f"體感: {weather_info.get('舒適度', '無資料')}"                )                embed.add_field(                    name=time_str,                    value=value,                    inline=True                )            embed.set_footer(text="資料來源: 中央氣象署")            return embed        except Exception as e:            logger.error(f"格式化鄉鎮天氣資料時發生錯誤: {str(e)}")            return discord.Embed(                title="❌ 錯誤",                description="格式化天氣資料時發生錯誤，請稍後再試",                color=discord.Color.red()            )    @app_commands.command(        name="weather",        description="查詢地區36小時天氣預報"    )    async def weather(self, interaction: discord.Interaction):        """開啟一個下拉式選單來選擇要查詢的縣市天氣預報"""        try:            # 創建下拉式選單視圖            view = WeatherSelectView(self)                        # 發送選擇提示訊息            embed = discord.Embed(                title="🌤️ 天氣查詢",                description="請從下方選單選擇要查詢的縣市",                color=discord.Color.blue()            )                        embed.add_field(                name="📋 天氣資訊包含",                value="• 未來36小時天氣預報\n• 降雨機率\n• 溫度範圍\n• 舒適度指數",                inline=False            )                        embed.add_field(                name="⏱️ 選單有效時間",                value="此選單將在2分鐘後自動失效",                inline=False            )                        embed.set_footer(text="資料來源：交通部中央氣象署")                        await interaction.response.send_message(embed=embed, view=view)                    except Exception as e:            logger.error(f"創建天氣查詢選單時發生錯誤: {str(e)}")            await interaction.response.send_message(                embed=discord.Embed(                    title="❌ 錯誤",                    description="無法顯示天氣查詢選單，請稍後再試",                    color=discord.Color.red()                ),                ephemeral=True            )    @app_commands.command(        name="reservoir",        description="查詢水庫每日營運情況"    )    async def reservoir(self, interaction: discord.Interaction):        """開啟一個下拉式選單來選擇要查詢的水庫營運情況"""        try:            # 創建下拉式選單視圖            view = ReservoirSelectView(self)                        # 發送選擇提示訊息            embed = discord.Embed(                title="💧 水庫營運情況查詢",                description="請從下方選單選擇要查詢的水庫",                color=discord.Color.blue()            )                        embed.add_field(                name="📋 水庫資訊包含",                value="• 目前蓄水量\n• 有效容量\n• 蓄水百分比\n• 進出水量\n• 水情狀態",                inline=False            )                        embed.add_field(                name="⏱️ 選單有效時間",                value="此選單將在2分鐘後自動失效",                inline=False            )                        embed.set_footer(text="資料來源: 經濟部水利署")                        await interaction.response.send_message(embed=embed, view=view)                    except Exception as e:            logger.error(f"創建水庫查詢選單時發生錯誤: {str(e)}")            await interaction.response.send_message(                embed=discord.Embed(                    title="❌ 錯誤",                    description="無法顯示水庫查詢選單，請稍後再試",                    color=discord.Color.red()                ),                ephemeral=True            )    @app_commands.command(        name="water_info",        description="查詢水庫即時水情資料"    )    async def water_info(self, interaction: discord.Interaction):        """開啟一個下拉式選單來選擇要查詢的水庫水情資料"""        try:            # 創建下拉式選單視圖            view = WaterInfoSelectView(self)                        # 發送選擇提示訊息            embed = discord.Embed(                title="💧 水庫即時水情查詢",                description="請從下方選單選擇要查詢的水庫",                color=discord.Color.blue()            )                        embed.add_field(                name="📋 水情資訊包含",                value="• 目前水位\n• 有效容量\n• 有效蓄水量\n• 蓄水百分比\n• 進出水量\n• 水情狀態",                inline=False            )                        embed.add_field(                name="⏱️ 選單有效時間",                value="此選單將在2分鐘後自動失效",                inline=False            )                        embed.set_footer(text="資料來源: 經濟部水利署")                        await interaction.response.send_message(embed=embed, view=view)                    except Exception as e:            logger.error(f"創建水庫水情查詢選單時發生錯誤: {str(e)}")            await interaction.response.send_message(                embed=discord.Embed(                    title="❌ 錯誤",                    description="無法顯示水庫水情查詢選單，請稍後再試",                    color=discord.Color.red()                ),                ephemeral=True            )    @app_commands.command(        name="town_weather",        description="查詢鄉鎮天氣預報"    )    async def town_weather(self, interaction: discord.Interaction):        """顯示鄉鎮天氣預報選單"""        try:            # 使用下拉選單讓用戶選擇鄉鎮            view = TownWeatherSelectView(self)            await interaction.response.send_message(                "請選擇要查詢的鄉鎮：",                view=view,                ephemeral=True            )            logger.info(f"用戶 {interaction.user} 開啟了鄉鎮天氣預報選單")                    except Exception as e:            logger.error(f"顯示鄉鎮天氣預報選單時發生錯誤: {str(e)}")            await interaction.response.send_message(                embed=discord.Embed(                    title="❌ 錯誤",                    description="無法載入鄉鎮天氣預報選單，請稍後再試",                    color=discord.Color.red()                ),                ephemeral=True            )async def setup(bot):    await bot.add_cog(InfoCommands(bot))@echo off
echo Pushing changes to GitHub...
git add .
git commit -m "Automated commit by bot startup"
git push origin main
echo Starting the bot...
python bot.py
pause

